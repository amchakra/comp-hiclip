---
title: "Figure 4"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

#### Libraries

```{r include=FALSE}
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(primavera))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(paletteer))
suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(scales))
suppressPackageStartupMessages(library(tidyverse, warn.conflicts = FALSE))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(Biostrings))
suppressPackageStartupMessages(library(mixtools))
suppressPackageStartupMessages(library(stringi))
suppressPackageStartupMessages(library(UpSetR))
suppressPackageStartupMessages(library(GenomicFeatures))

```

#### Functions

```{r}
# http://tinyheero.github.io/2015/10/13/mixture-model.html
# 
#' Plot a Mixture Component
#' 
#' @param x Input data
#' @param mu Mean of component
#' @param sigma Standard deviation of component
#' @param lam Mixture weight of component

plot_mix_comps <- function(x, mu, sigma, lam) {
  lam * dnorm(x, mu, sigma)
}


get_basepairs_count <- function(forgi.df) {
  
  duplex_max.df <- forgi.df %>%
    group_by(id) %>%
    dplyr::filter(element_type == "s") %>%
    summarise(total_paired = sum(L_width)) %>%
    dplyr::select(id, total_paired)
  
  forgi.df <- left_join(forgi.df, duplex_max.df, by = "id")
  
  return(forgi.df)
}

get_unpaired_total <- function(forgi.df, group = NULL) {
  
  data_i.df <- forgi.df %>%
    group_by({{group}}, id) %>%
    dplyr::filter(element_type == "i") %>%
    replace(is.na(.), 0) %>%
    mutate(iloop_length_L = sum(L_width),
           iloop_length_R = sum(R_width)) %>%
    dplyr::select(id, {{group}}, iloop_length_L, iloop_length_R) %>%
    ungroup() %>%
    distinct() %>%
    rowwise() %>%
    mutate(total_unpaired = sum(iloop_length_L, iloop_length_R)) %>%
    #dplyr::select(-c(iloop_length_L, iloop_length_R)) %>%
    ungroup()
   #data.df <- left_join(data.df, data_i.df, by = c(str(quote(group)), "id"))
  
  return(data_i.df)
}

get_paired_metric <- function(clusters.df, group = NULL) {
  
  paired_metric.df <- clusters.df %>%
    dplyr::select({{group}}, name, total_paired, total_unpaired) %>%
    replace(is.na(.), 0) %>%
    distinct() %>%
    rowwise() %>%
    mutate(paired_to_total_ratio = total_paired*2/(total_paired*2 + total_unpaired)) %>%
    ungroup() %>%
    dplyr::select({{group}}, name, paired_to_total_ratio)
  
  return(paired_metric.df)
}

get_paired_regions <- function(id, L_db, R_db) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  l_start <- l_brackets[1]
  l_end <- l_brackets[length(l_brackets)]
  
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  r_start <- r_brackets[1]
  r_end <- r_brackets[length(r_brackets)]
  
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  results.ls <- list(id = id, l_start = l_start, l_end = l_end, 
                     r_start=r_start, r_end=r_end)
  
  return(results.ls)
  
}
```


```{r}
trim_duplex_overhangs <- function(clusters.df) {
  
  # Separate L_db and R_db
  clusters.df <- clusters.df %>%
    separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)
  
  # Get positions of paired residues within structures of each arm
  clusters.df <- clusters.df %>%
    rowwise() %>%
    mutate(paired_regions = list(get_paired_regions(id, L_db, R_db))) %>%
    mutate(L_duplex_start = paired_regions$l_start, 
           L_duplex_end = paired_regions$l_end,
           R_duplex_start = paired_regions$r_start, 
           R_duplex_end = paired_regions$r_end) %>%
    ungroup() %>%
    dplyr::select(-paired_regions)
  
  # Adjust genomic coordinates to only include the paired region
  clusters.df <- clusters.df %>%
    rowwise() %>%
    mutate(L_genomic_duplex_start = case_when(L_genomic_strand == "+" ~ L_genomic_start + L_duplex_start - 1,
                                      TRUE ~ L_genomic_end - L_duplex_end + 1),
           L_genomic_duplex_end = case_when(L_genomic_strand == "+" ~ L_genomic_start + L_duplex_end - 1,
                                    TRUE ~ L_genomic_end - L_duplex_start + 1),
           R_genomic_duplex_start = case_when(L_genomic_strand == "+" ~ R_genomic_start + R_duplex_start - 1,
                                      TRUE ~ R_genomic_end - R_duplex_end + 1),
           R_genomic_duplex_end = case_when(L_genomic_strand == "+" ~ R_genomic_start + R_duplex_end - 1,
                                    TRUE ~ R_genomic_end - R_duplex_start + 1)) %>%
    ungroup()
  
  return(clusters.df)
}


correct_bulge_positions <- function(forgi.df) {
  # Forgi output places all asymmetric internal loops and bulges on the left side, even when they should be on the right.
  # If such cases exist, swap them to the right
  # !!!THIS FUNCTION MUST BE APPLIED ON SINGLE DUPLEX STRUCTURES
  
  stem_L.df <- forgi.df %>%
    group_by(Experiment, id) %>%
    dplyr::filter(element_type == "s") %>%
    mutate(stem_L_limit = max(L_end) ) %>%
    dplyr::select(id, Experiment, stem_L_limit) %>%
    ungroup() %>%
    distinct()

  forgi.df <- left_join(forgi.df, stem_L.df, by = c("Experiment", "id"))
  
  if (nrow(dplyr::filter(forgi.df, L_start > stem_L_limit)) == 0) {
      
    forgi.df <- forgi.df %>%
        dplyr::select(-stem_L_limit)
    
  } else {
      
    forgi.df <- forgi.df %>%
      rowwise() %>%
      mutate(swap = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~  "yes", TRUE ~ "no"),
              R_start = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~ as.double(L_start),
                                  TRUE ~ as.double(R_start)),
              R_end = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~ as.double(L_end),
                                 TRUE ~ as.double(R_end)),
              R_width = case_when((element_type == "i") & (as.double(L_start) > stem_L_limit) ~ as.double(L_width),
                                   TRUE ~ as.double(R_width))) %>%
      ungroup()
    
    forgi.df <- forgi.df %>%
      rowwise() %>%
      mutate(L_start = case_when(swap == "yes" ~ 0, 
                                 TRUE ~ as.double(L_start)),
             L_end = case_when(swap == "yes" ~ 0,
                                   TRUE ~ as.double(L_end)),
             L_width = case_when(swap == "yes" ~ 0,
                                     TRUE ~ as.double(L_width))) %>%
          ungroup() %>%
          dplyr::select(-stem_L_limit, -swap)
    
      }
  return(forgi.df)
}

get_nucleotide_frequency <- function(duplexes.df) {
  
   # Separate L_db and R_db
  duplexes.df <- duplexes.df %>%
    separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)
  
  # Extract the paired residues from each arm's sequence
  duplexes.df <- duplexes.df %>%
    rowwise() %>%
    mutate(paired_regions = list(get_paired_residues(id, L_db, L_sequence, R_db, R_sequence))) %>%
    mutate(L_paired_residues = paired_regions$l_paired_residues,
           R_paired_residues = paired_regions$r_paired_residues) %>%
    ungroup() %>%
    dplyr::select(-paired_regions)
  
  duplexes.df <- duplexes.df %>%
      dplyr::filter(!is.na(L_paired_residues)) %>%
      dplyr::filter(!is.na(R_paired_residues))
  
  # Calculate nucleotide frequencies for ech arm
  L_seq <- DNAStringSet(duplexes.df$L_paired_residues)
  R_seq <- DNAStringSet(duplexes.df$R_paired_residues)
  R_seq <- Biostrings::reverse(R_seq) # Need to reverse the R arm paired sequence
  
  L_freq <- as.data.frame(oligonucleotideFrequency(L_seq, width = 1, as.prob=TRUE))
  R_freq <- as.data.frame(oligonucleotideFrequency(R_seq, width = 1, as.prob=TRUE))
  
  colnames(L_freq) <- paste0(colnames(L_freq), "_L")
  colnames(R_freq) <- paste0(colnames(R_freq), "_R")
  duplexes.df <- dplyr::bind_cols(duplexes.df, L_freq, R_freq)
  
  # Purine content - assign maximal purine arm
  duplexes.df <- duplexes.df %>%
    rowwise() %>% 
    mutate(L_pur = sum(c(A_L, G_L)), # purine total per hybrid
            R_pur = sum(c(A_R, G_R))) %>%
    mutate(max_pur = max(L_pur, R_pur)) %>%
    mutate(maximal_purine_arm = case_when((max_pur == L_pur) ~ "L", # assign maximal purine arm
                            TRUE ~ "R")) %>%
    ungroup() %>%
    dplyr::select(-L_pur, -R_pur, -max_pur)
  
  # Reorient duplex frequencies based on maximal purine content (column "maximal_purine_arm")
  nuc_freq_max_pur_arm.df <- duplexes.df %>%
    dplyr::filter(maximal_purine_arm == "L") %>%
    mutate(A_freq_max_pur_arm = A_L, A_freq_min_pur_arm = A_R,
             G_freq_max_pur_arm = G_L, G_freq_min_pur_arm = G_R,
             C_freq_max_pur_arm = C_L, C_freq_min_pur_arm = C_R,
             U_freq_max_pur_arm = T_L, U_freq_min_pur_arm = T_R)
  nuc_freq_min_pur_arm.df <- duplexes.df %>%
    dplyr::filter(maximal_purine_arm == "R") %>%
    mutate(A_freq_max_pur_arm = A_R, A_freq_min_pur_arm = A_L,
             G_freq_max_pur_arm = G_R, G_freq_min_pur_arm = G_L,
             C_freq_max_pur_arm = C_R, C_freq_min_pur_arm = C_L,
             U_freq_max_pur_arm = T_R, U_freq_min_pur_arm = T_L)
    
  nuc_freq_reordered.df <- rbind(nuc_freq_max_pur_arm.df, nuc_freq_min_pur_arm.df)
  stopifnot(nrow(nuc_freq_reordered.df) == nrow(duplexes.df))
  
  nuc_freq_reordered.df <- nuc_freq_reordered.df %>%
    dplyr::select(-union(colnames(L_freq), colnames(R_freq)))
    
  return(nuc_freq_reordered.df)
  
}

plot_stacked_barchart <- function(data.df, column, group=NULL, simplify=TRUE) {
  
  if (!("id" %in% colnames(data.df))) {
    data.df$id <- rownames(data.df)
    
  } else {
    #next
    data.df$id <- data.df$id
  }
  
  data_counts.df <- data.df %>%
    dplyr::select(id, {{group}}, {{column}}) %>%
    distinct() %>%
    group_by({{group}}, {{column}}) %>%
    summarise(counts = n()) %>%
    arrange(desc({{column}})) %>%
    mutate(percentage = scales::percent(counts / sum(counts), accuracy = 0.01)) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    ungroup() %>%
    group_by({{group}}) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
    mutate(pos = cumsum(percentage) - percentage/2)
  
  
  if (simplify) {
    data_counts.df <- data_counts.df %>%
      mutate(category = case_when((percentage <= 0.75) ~ "Other",
                                 (percentage > 0.7) ~ {{column}}))
    
    data_counts.df <- data_counts.df %>%
      group_by({{group}}, category) %>%
      mutate(percentage = sum(percentage)) %>%
      ungroup() %>%
      dplyr::select(category, percentage, {{group}}) %>%
      distinct() %>%
      arrange(desc(category)) %>%
      mutate(pos = cumsum(percentage) - percentage/2) 
    
  } else {
    
    data_counts.df <- data_counts.df %>%
      mutate(category = {{column}})
  }
  
  bar = ggplot() + 
    geom_bar(aes(y = percentage, x = "", fill = category), data = data_counts.df,
                            stat="identity", width = 0.5) +  # color="black"
    ggrepel::geom_text_repel(data = data_counts.df, aes(x = "", y = pos, label=paste0(round(percentage, 1),"%")), size=5, nudge_x = 0.4,
                                 segment.size = 0.5, segment.color = '#515A5A') + # label=paste0(round(percentage, 2),"%"))
    facet_grid(cols = vars({{group}})) +
    #facet_wrap(. ~ Experiment, scales = "free") +
    paletteer::scale_fill_paletteer_d("rcartocolor::Earth", direction = -1) +
    theme(legend.position="right", legend.direction="vertical",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") +
    theme_minimal()
  
  return(bar)
  
}

```


```{r}
get_paired_residues <- function(id, L_db, L_sequence, R_db, R_sequence) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  # paired_residues_count <- length(l_brackets)
  l_paired_residues <- paste(str_sub(L_sequence, start = l_brackets, end = l_brackets), collapse = '')
  r_paired_residues <- paste(str_sub(R_sequence, start = r_brackets, end = r_brackets), collapse = '')
  
  results.ls <- list(id = id, l_paired_residues = l_paired_residues, r_paired_residues = r_paired_residues)
  
  return(results.ls)
  
}

#' A function to find all locations of a specific residue within a sequence
#'
#' @description 
#' This function will find and locate the letter "residue" within a string sequence "x"
#' 
#' @param residue one letter you'd like to find
#' @param x the string you would like to find it in
find_residue <- function(residue, x) {
  pos <- str_locate_all(x, residue)
  return(unique(unlist(pos)))
}


get_gc_pairs <- function(data.df) {
  
  gc.df <- data.df %>%
    mutate_at("R_paired_residues", stri_reverse) %>%  # need to reverse seq of R arm
    rowwise() %>%
    mutate(G_pos_L = list(find_residue(L_paired_residues, residue = "G")),
           C_pos_L = list(find_residue(L_paired_residues, residue = "C")),
           G_pos_R = list(find_residue(R_paired_residues, residue = "G")),
           C_pos_R = list(find_residue(R_paired_residues, residue = "C"))) %>%
    ungroup()
  
  # Obtain the positions of Gs and Cs in L and see if the same but complement in R
  gc.df <- gc.df %>%
    rowwise() %>%
    mutate(gc_pairs = list(intersect(G_pos_L, C_pos_R)),
           cg_pairs = list(intersect(C_pos_L, G_pos_R))) %>%
    mutate(GC_pos = list(union(gc_pairs, cg_pairs))) %>%
    mutate(GC_pos_count = length(GC_pos)) %>%
    mutate(GC_percentage = GC_pos_count*100/total_paired) %>%
    ungroup() %>%
    dplyr::select(id, GC_pos, GC_pos_count, GC_percentage) %>%
    distinct()
  
  data.df <- left_join(data.df, gc.df, by = "id") 
  
  return(data.df)
}
```


```{r}
plot_nucleotide_frequency <- function(data.df) {

  # Prepare for plotting
  high_pur.df <- data.df %>% 
    dplyr::select(Experiment, name, A_freq_max_pur_arm, G_freq_max_pur_arm, C_freq_max_pur_arm, U_freq_max_pur_arm)
  
  high_pur.df <- rowid_to_column(high_pur.df)
  long_high_pur.df <- high_pur.df %>% 
    gather(residue, frequency, A_freq_max_pur_arm:U_freq_max_pur_arm)
  long_high_pur.df$arm = "High purine arm"
  
  low_pur.df <- data.df %>% 
    dplyr::select(Experiment, name, A_freq_min_pur_arm, G_freq_min_pur_arm, C_freq_min_pur_arm, U_freq_min_pur_arm)
  
  low_pur.df <- rowid_to_column(low_pur.df)
  
  long_low_pur.df <- low_pur.df %>% 
    gather(residue, frequency, A_freq_min_pur_arm:U_freq_min_pur_arm)
  long_low_pur.df$arm = "Low purine arm"
  nuc_freq.df <- rbind(long_high_pur.df, long_low_pur.df)
  nuc_freq.df$residue <- str_sub(nuc_freq.df$residue, 1,1) # trim string to get nucleotide (first) letter
  
  # Plot individual nucleotide frequencies
  nuc_freq.gg <- ggplot(nuc_freq.df, aes(y=rowid, x=frequency, color = residue)) +
    geom_smooth(se=F, method = "loess", span = 0.4, orientation = "y") +
    facet_grid(cols = vars(arm), rows = vars(Experiment), scales = "free_y") +
    xlab("Frequency") +
    ylab("ID (decreasing number of bp)") +
    #ylim(0, 1) +
    theme_minimal_grid() + 
  theme(legend.position = "top") +
    scale_color_manual(values = c("dodgerblue4","goldenrod3","firebrick", "darkgreen"))
  
  return(list(data = nuc_freq.df, plot = nuc_freq.gg))
  
}
```


#### Data

```{r}
data.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip"
plots.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/plots/figure_4"
```

```{r}
# Clusters (collapsed)

stau1.dt <- fread(paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.collapsed_plus_nonhybrids.tsv.gz"))
stau1.mfe.dt <- fread(paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.collapsed.mfe.tsv.gz"))
paris.dt <- fread(paste0(data.dir,"/paris_atlas/all.atlas_clusters.gc.annotated.tsv.gz"))
paris.mfe.dt <- fread(paste0(data.dir, "/paris_atlas/paris.all.atlas_clusters.gc.annotated.mfe.tsv.gz"))

short_range.mfe.dt <- fread(paste0(data.dir, "/short_range/sept_2021/short_range_duplexes.mfe.tsv.gz"))
short_range.forgi.dt <- fread(paste0(data.dir, "/short_range/sept_2021/short_range_duplexes.forgi.tsv.gz"))

# Structure annotation
stau1_forgi.dt <- fread(paste0(data.dir,"/stau1_atlas/merged_atlas.clusters.collapsed.forgi.tsv.gz"))

# paris: only intragenic 3'UTR
paris_forgi.dt <- fread(paste0(data.dir,"/paris_atlas/paris.3utr.all.atlas_clusters.gc.annotated.forgi.tsv.gz"))

# Clustered hybrids
stau1.hybrids.dt <- fread(paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.tsv.gz"))
paris.hybrids.dt <- fread(paste0(data.dir, "/paris_atlas/all.atlas_clusters.gc.annotated.tsv.gz"))
```

```{r}
# Merge predicted structures mfe and forgi tables to the proximity ligation dupelxes

# Filter only for IDs in the cluster files
id.ls <- dplyr::filter(stau1.dt, str_detect(cluster, "ID"))$name

short_range.mfe.dt <- dplyr::filter(short_range.mfe.dt, name %in% id.ls)
short_range.forgi.dt <- dplyr::filter(short_range.forgi.dt, id %in% id.ls)

short_range.mfe.dt <- dplyr::select(short_range.mfe.dt, name, L_sequence, R_sequence, mfe, structure, mean_shuffled_mfe, sd_shuffled_mfe)
stau1.mfe.dt <- dplyr::select(stau1.mfe.dt, name,L_sequence, R_sequence, mfe, structure, mean_shuffled_mfe, sd_shuffled_mfe)

mfe.dt <- rbind(stau1.mfe.dt, short_range.mfe.dt)
stopifnot(nrow(mfe.dt) == nrow(stau1.dt)) 

# Add mfe columns to stau1.dt
stau1.dt <- left_join(stau1.dt, mfe.dt, by = "name")
stau1.dt <- distinct(stau1.dt)
#fwrite(stau1.dt, paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.collapsed_plus_nonhybrids.mfe.tsv.gz"), sep = "\t")

# Now forgi
stau1_forgi.dt <- rbind(stau1_forgi.dt, short_range.forgi.dt)
stau1_forgi.dt <- distinct(stau1_forgi.dt)
#fwrite(stau1_forgi.dt, paste0(data.dir, "/stau1_atlas/merged_atlas.clusters.collapsed_plus_nonhybrids.forgi.tsv.gz"), sep = "\t")
```

***
> STAU1 hiCLIP cluster counts

The number of STAU1 clusters is `r nrow(stau1.dt)`

```{r}
# Exclude rRNA and tRNA from PARIS duplexes
paris.dt <- paris.dt[!(L_seqnames == "rRNA_45S" & R_seqnames == "rRNA_45S")]
paris.dt <- paris.dt[!(L_seqnames == "rDNA" & R_seqnames == "rDNA")]
paris.dt <- paris.dt[!(L_seqnames == "rRNA_5S" & R_seqnames == "rRNA_5S")]
paris.dt <- paris.dt[!(L_seqnames == "rRNA5S" & R_seqnames == "rRNA5S")]
paris.dt <- paris.dt[!grepl("tRNA", L_seqnames)]
paris.dt <- paris.dt[!grepl("tRNA", R_seqnames)]
```

The number of PARIS duplexes excluding rRNA and tRNA is `r nrow(paris.dt)`
The number of STAU1 hiCLIP + short-range duplexes is `r nrow(stau1.dt)`

# Fig 4 A: Duplex locations

#### Intramolecular vs intermolecular

```{r}
stau1.dt <- stau1.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))

intra_stau1.dt <- stau1.dt %>%
  dplyr::filter(type == "Intra-transcript")
```

There are `r nrow(intra_stau1.dt)` intramolecular duplexes within STAU1 hiCLIP duplex atlas.


```{r warning=FALSE}
# Filter out duplexes with no duplex binding energy
intra_stau1.dt <- intra_stau1.dt %>%
  dplyr::filter((!str_detect(L_sequence, "N"))) %>%
  dplyr::filter((!str_detect(R_sequence, "N")))

nrow(intra_stau1.dt)
```

***
> STAU1 locations

```{r}
interregion_colours <- c("CDS - CDS" = "#638b66", "CDS - ncRNA" = "#B03A2E", "CDS - UTR3" = "#A9CCE3",
                    "CDS - UTR5" = "#C39BD3", "ncRNA - ncRNA" = "#fbb04e", "Other" = "#AAB7B8",
                    "UTR3 - UTR3" = "#f47942", "UTR5 - UTR5" = "#a2ceaa")
```

```{r warning=FALSE}
# Filter out intronic regions 
intra_stau1.dt <- intra_stau1.dt %>%
  dplyr::filter(L_region != "intron" & R_region != "intron")

nrow(intra_stau1.dt)

stau1_duplex_regions.df <- intra_stau1.dt %>%
  dplyr::filter(!str_detect(cluster, "ID")) %>% # exclude predicted duplexes 
  rowwise() %>%
  mutate(region_pairs = paste(sort(c(L_region, R_region)), collapse = " - ")) %>%
  ungroup()

stau1.regions.gg <- plot_stacked_barchart(stau1_duplex_regions.df, region_pairs, simplify = T) +
  ggtitle("STAU1") +
  scale_fill_manual(values = interregion_colours) +
  theme_minimal_grid() +
  guides(fill=guide_legend(title="Duplex location")) +
  guides(fill=guide_legend(title="Duplex arm location")) +
    theme(legend.position = "right") 
  
stau1.regions.gg
# ggsave(paste0(plots.dir, "/stau1_arm_region_pairs.pdf"), stau1.regions.gg, width = 5, height = 8, dpi = 300)

```



***
> PARIS locations

#### Intramolecular vs intermolecular

```{r}
paris.dt <- paris.dt %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))
intra_paris.dt <- paris.dt %>%
  dplyr::filter(type == "Intra-transcript")

# Filter out intronic regions 
intra_paris.dt <- intra_paris.dt %>%
  dplyr::filter(L_region != "intron" & R_region != "intron")

intra_paris_duplex_regions.df <- intra_paris.dt %>%
  rowwise() %>%
  mutate(region_pairs = paste(sort(c(L_region, R_region)), collapse = " - ")) %>%
  ungroup()

nrow(intra_paris.dt)
```

The are `r nrow(intra_paris.dt)` intra-transcript PARIS duplexes, excluding introns. 

```{r}
paris_regions.gg <- plot_stacked_barchart(intra_paris_duplex_regions.df, region_pairs, simplify = TRUE) +
  ggtitle("PARIS") +
  scale_fill_manual(values = interregion_colours) +
  theme_minimal_grid() +
  guides(fill=guide_legend(title="Duplex location"))

paris_regions.gg
# ggsave(paste0(plots.dir, "/paris_arm_region_pairs.pdf"), paris_regions.gg, width = 5, height = 8, dpi = 300)
```
> Filter intra-transcript 3'UTR duplexes from both datasets

To get more comparable datasets, we focused on the 3'UTR intra-transcript duplexes for both STAU1 and PARIS. 

```{r}
stau1.utr3.df <- intra_stau1.dt %>%
  dplyr::filter(L_gene_id == R_gene_id & L_region == "UTR3" & R_region == "UTR3") %>%
  mutate(Experiment = "STAU1")

paris.mfe.dt <- paris.mfe.dt %>%
  rowwise() %>%
  mutate(type = case_when(L_gene_id == R_gene_id ~ "Intra-transcript",
                          TRUE ~ "Inter-transcript"))

paris.utr3.df <- paris.mfe.dt %>%
  dplyr::filter(L_gene_id == R_gene_id & L_region == "UTR3" & R_region == "UTR3") %>%
  mutate(Experiment = "PARIS")


# Filter structure annotation files for the 3'UTR-3'UTR intra-transcript clusters
utr3_stau1_forgi.df <- semi_join(stau1_forgi.dt, stau1.utr3.df, by = c("id" = "name"))
utr3_paris_forgi.df <- semi_join(paris_forgi.dt, paris.utr3.df, by = c("id" = "name"))
utr3_stau1_forgi.df$Experiment <- "STAU1"
utr3_paris_forgi.df$Experiment <- "PARIS"

# Append datasets
utr3_clusters.df <- rbind(stau1.utr3.df, paris.utr3.df)
```


Clusters remaining in the STAU1 data: `{r} nrow(stau1.utr3.df)`
Clusters remaining in the PARIS data: `{r} nrow(paris.utr3.df)`


```{r}
nrow(stau1.utr3.df)
nrow(paris.utr3.df)
```

Need to adjust the genomic and transcriptomic coordinates to focus on the stem of the structure (for clustered duplexes only because for the short-range duplexes already done for Fig 3)

```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  mutate(detection_type = case_when(!str_detect(cluster, "ID") ~ "Proximity ligation",
                                    TRUE ~ "Predicted"))

# only proximity ligation hybrids
exp.utr3.df <- utr3_clusters.df %>%
  dplyr::filter(detection_type == "Proximity ligation")

nrow(dplyr::filter(exp.utr3.df, Experiment == "STAU1"))
```

There are `r nrow(exp.utr3.df)` experimentally determined duplexes within the STAU1 atlas

```{r}
predicted_stau1.utr3.df <- utr3_clusters.df %>%
  dplyr::filter(detection_type == "Predicted")

exp.utr3.df <- trim_duplex_overhangs(exp.utr3.df)

predicted_stau1.utr3.df <- predicted_stau1.utr3.df %>%
  mutate(L_genomic_duplex_start = L_genomic_start,
         R_genomic_duplex_start = R_genomic_start,
         L_genomic_duplex_end = L_genomic_end,
         R_genomic_duplex_end = R_genomic_end)

stopifnot(nrow(utr3_clusters.df) == nrow(rbind(data.table(exp.utr3.df), data.table(predicted_stau1.utr3.df), fill = TRUE)))

utr3_clusters.df <- rbind(data.table(exp.utr3.df), data.table(predicted_stau1.utr3.df), fill = TRUE)
utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS"))
```


# Fig 4 B: Overlap with PARIS for 3'UTR intra-transcript duplexes

Comparison with PARIS HEK293 (Lu et al. 2016)

```{r}
exp_stau1.utr3.df <- dplyr::filter(exp.utr3.df, Experiment == "STAU1")
stau1.utr3.dt <- data.table(exp_stau1.utr3.df)
paris.utr3.dt <- data.table(paris.utr3.df)

stau1.utr3.dt <- reorient_hybrids(stau1.utr3.dt)
paris.utr3.dt <- reorient_hybrids(paris.utr3.dt)
Sys.setenv(PATH="/Users/iosubi/opt/miniconda3/bin/")
bedpe.colnames <- c("L_seqnames", "L_start", "L_end", "R_seqnames", "R_start", "R_end", "name", "count", "L_strand", "R_strand")
stau1.utr3.bedpe.dt <- stau1.utr3.dt[, ..bedpe.colnames]
stau1.utr3.bedpe.dt[, `:=`(
  L_start = L_start - 1,
  R_start = R_start - 1
)]

paris.utr3.bedpe.dt <- paris.utr3.dt[, ..bedpe.colnames]
paris.utr3.bedpe.dt[, `:=`(
  L_start = L_start - 1,
  R_start = R_start - 1
)]

stau1.bedpe <- tempfile(tmpdir = getwd(), fileext = ".bedpe")
paris.bedpe <- tempfile(tmpdir = getwd(), fileext = ".bedpe")

ol <- tempfile(tmpdir = getwd(), fileext = ".bedpe")

fwrite(stau1.utr3.bedpe.dt, file = stau1.bedpe, sep = "\t", col.names = FALSE)
fwrite(paris.utr3.bedpe.dt, file = paris.bedpe, sep = "\t", col.names = FALSE)
cmd <- paste("bedtools pairtopair -rdn -a", stau1.bedpe, "-b", paris.bedpe, ">", ol)
system(cmd)

bedpe.dt <- fread(ol, col.names = c(paste0(bedpe.colnames, ".x"), paste0(bedpe.colnames, ".y")))
file.remove(stau1.bedpe)
file.remove(paris.bedpe)
file.remove(ol)

upset.input <- c("STAU1" = nrow(stau1.utr3.dt) - nrow(bedpe.dt),
               "PARIS" = nrow(paris.utr3.dt) - nrow(bedpe.dt),
               "STAU1&PARIS" = nrow(bedpe.dt))
```

```{r}
upset.input
```


```{r}
pdf(file.path(plots.dir, "stau1_paris_utr3_upset.pdf"), width = 7, height = 5)
UpSetR::upset(fromExpression(upset.input), 
      order.by = "freq",
      mainbar.y.label = "Intersecting number of duplexes",
      sets.x.label = "Total number of duplexes")
dev.off()
```

# Fig 4 C: Hybrid spans


```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(duplex_span = case_when(L_genomic_strand == "+" ~ R_genomic_duplex_start - L_genomic_duplex_end + 1 - 2,
                                  L_genomic_strand == "-" ~ L_genomic_duplex_start - R_genomic_duplex_end + 1 - 2)) %>%
  ungroup()

span_median <- utr3_clusters.df %>%
    group_by(Experiment, detection_type) %>%
    dplyr::summarize(Median = median(duplex_span, na.rm=TRUE))
span_median

span_mean <- utr3_clusters.df %>%
    group_by(Experiment, detection_type) %>%
    dplyr::summarize(Mean = mean(duplex_span, na.rm=TRUE))
span_mean
```

```{r}
duplex_span.gg <- ggplot(utr3_clusters.df, aes(x = duplex_span, color = Experiment)) + 
  geom_density(adjust = 1.5) +
  scale_linetype_manual(values=c("dotted", "solid")) +
  scale_x_log10() + annotation_logticks(sides = "b") +
  scale_color_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "right") +
  ylab("Density") +
  xlab("Duplex span (nt) ") +
  geom_vline(data=span_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  facet_grid(rows = vars(factor(detection_type, levels = c("Proximity ligation", "Prediction"))), scales = "free_y")

duplex_span.gg
# ggsave(paste0(plots.dir, "/duplex_span.pdf"), duplex_span.gg, dpi = 300, width = 6.5, height = 4)
```
### Span groups

```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  dplyr::mutate(span_group = case_when(str_detect(cluster, "ID") ~ "predicted short range",
                                       !str_detect(cluster, "ID") & duplex_span <= 100 & duplex_span >= 25 ~ "medium range",
                                       !str_detect(cluster, "ID") & duplex_span < 25 ~ "short range",
                                       !str_detect(cluster, "ID") & duplex_span > 100 ~ "long range"))

plot_stacked_barchart(data.df = dplyr::filter(utr3_clusters.df, !str_detect(cluster, "ID")), column = span_group, group = Experiment, simplify = FALSE)
```

# Fig S4 A

We can fit a 2-component Gaussian mixture model to the bimodal STAU1 distribution

```{r}
# Extract data for gauss mixture model

set.seed(42)
mixmdl <- normalmixEM(log10(utr3_clusters.df[utr3_clusters.df$Experiment == "STAU1" & utr3_clusters.df$detection_type == "Proximity ligation" & utr3_clusters.df$duplex_span > 0 ,]$duplex_span), k = 2)

mix.gg <- ggplot() +
  geom_histogram(data = data.frame(x = mixmdl$x), aes(x, ..density..), bins = 100, fill = "grey75") +
  stat_function(data = data.frame(x = mixmdl$x), geom = "line", fun = plot_mix_comps,
                args = list(mixmdl$mu[1], mixmdl$sigma[1], lam = mixmdl$lambda[1]),
                colour = "red", lwd = 1.5) +
  stat_function(data = data.frame(x = mixmdl$x), geom = "line", fun = plot_mix_comps,
                args = list(mixmdl$mu[2], mixmdl$sigma[2], lam = mixmdl$lambda[2]),
                colour = "blue", lwd = 1.5) +
  scale_x_continuous(labels = c(1, 10, 100, 1000, 10000)) +
  labs(x = "Duplex span (nt)",
       y = "Density") +
  theme_minimal_grid()

mix.gg

# ggsave(paste0(plots.dir, "/duplex_span_gauss_mixture.pdf"), mix.gg, dpi = 300, width = 4, height = 4)
```

This gives us two distributions with mean duplex spans of `r round(10^mixmdl$mu, 3)[1]` and `r round(10^mixmdl$mu, 3)[2]` and lambdas of `r round(mixmdl$lambda, 3)[1]` and `r round(mixmdl$lambda, 3)[2]` respectively.

```{r}
round(10^mixmdl$mu, 3)[1]

round(10^mixmdl$mu, 3)[2]

round(mixmdl$lambda, 3)[1]

round(mixmdl$lambda, 3)[2]
```

# Fig 4 D: Stem lengths

Compare the number of paired residues within each duplex

```{r}
# get base-pairs count
utr3_stau1_forgi.df <- get_basepairs_count(utr3_stau1_forgi.df)
utr3_paris_forgi.df <- get_basepairs_count(utr3_paris_forgi.df)

utr3_forgi.df <- rbind(utr3_stau1_forgi.df, utr3_paris_forgi.df)

utr3_bp.df <- utr3_forgi.df %>%
  distinct(Experiment, id, total_paired)

utr3_clusters.df <- left_join(utr3_clusters.df, utr3_bp.df, by = c("Experiment", c("name" = "id")))
```

```{r}
# Wilcox.test
stau1.bp.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$total_paired
paris.bp.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS" & !str_detect(cluster, "ID"))$total_paired

median(stau1.bp.ls)
median(paris.bp.ls)
mean(stau1.bp.ls)
mean(paris.bp.ls)

wilcox.test(stau1.bp.ls, paris.bp.ls, alternative = "two.sided")
```

```{r}
span_counts <- utr3_clusters.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(counts = n()) 
```

```{r}
utr3_clusters.df$span_group <- factor(utr3_clusters.df$span_group, levels = c("long range", "medium range", "short range", "predicted short range"))
utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS"))

total_paired.gg <- ggplot(utr3_clusters.df,
                         aes(x = Experiment, y=total_paired, fill=Experiment)) +
  geom_boxplot(outlier.shape = NA, width = 0.5) +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Base-pairs per duplex (bp)") +
  ylim(-1.5, 40) +
  facet_grid(cols = vars(factor(span_group, levels=c("long range", "medium range", "short range", "predicted short range")))) +
  geom_label(data = span_counts, aes(label=counts, y = -1.5), label.padding = unit(0.25, "lines"),
            position=position_dodge(width=1.0), inherit.aes = TRUE,  fill = "white", size = 3)
total_paired.gg 
# ggsave(paste0(plots.dir, "/total_paired.pdf"), total_paired.gg, dpi = 300, width = 5, height = 6)
```

# Fig 4 E: Hybridisation energy

```{r}
# Normalise MFE scores to number of paired res

utr3_clusters.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(normalised_mfe = mfe/total_paired,
         normalised_mean_shuffled_mfe = mean_shuffled_mfe/total_paired,
         normalised_sd_shuffled_mfe = sd_shuffled_mfe/total_paired) %>%
  ungroup()
```


```{r}
# Test
stau1.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$mfe
stau1.norm_mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$normalised_mfe
stau1.shuffled.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1" & !str_detect(cluster, "ID"))$normalised_mean_shuffled_mfe

paris.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$mfe
paris.norm_mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$normalised_mfe
paris.shuffled.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$normalised_mean_shuffled_mfe

# Differences vs shuffled
# STAU1
wilcox.test(stau1.norm_mfe.ls, stau1.shuffled.mfe.ls)

# PARIS
wilcox.test(paris.norm_mfe.ls, paris.shuffled.mfe.ls)

# Absolute mfe difference vs PARIS
mean(stau1.mfe.ls) - mean(paris.mfe.ls)

# MFE per bp difference
mean(stau1.norm_mfe.ls) - mean(paris.norm_mfe.ls)
wilcox.test(stau1.norm_mfe.ls, paris.norm_mfe.ls)
```

The absolute mean difference in MFE between STAU1 and PARIS is `r mean(stau1.mfe.ls) - mean(paris.mfe.ls)`
The mean difference per bp in MFE between STAU1 and PARIS is `r mean(stau1.norm_mfe.ls) - mean(paris.norm_mfe.ls)`

Wilxox test p value for the MFE/bp difference is: `r wilcox.test(stau1.norm_mfe.ls, paris.norm_mfe.ls)$p.val`

```{r}
wilcox.test(stau1.norm_mfe.ls, paris.norm_mfe.ls)$p.val
```

```{r}
length(stau1.norm_mfe.ls)
```

The MFE/bp median is: 


```{r}
mfe_median <- utr3_clusters.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(normalised_mfe, na.rm = TRUE))
mfe_median

utr3_clusters_mfe.df <- pivot_longer(utr3_clusters.df, cols = c(normalised_mfe, normalised_mean_shuffled_mfe), names_to = "Sample", values_to = "MFE")

utr3_clusters_mfe.df <- utr3_clusters_mfe.df %>%
  mutate(Sample = case_when((Sample == "normalised_mfe") ~ "STAU1",
                            (Sample == "normalised_mean_shuffled_mfe") ~ "Shuffled control"))


mfe.dens2.gg <- ggplot(utr3_clusters_mfe.df, aes(x = MFE, linetype = Sample, color = Experiment)) + 
  geom_density(alpha = 0.8) +
  #annotate("text", label = "p < 2.2e-16", x = -1, y = 1.7) +
  scale_linetype_manual(values=c("longdash", "solid")) +
  scale_color_tableau() +
  theme_minimal_grid() + 
  facet_grid(rows = vars(Experiment), cols = vars(span_group)) +
  theme(legend.position = "top") +
  ylab("Density") +
  xlab("Normalised hybridisation energy (kcal/mol)/bp") +
  geom_vline(data=mfe_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  xlim(-2.5, 0)

mfe.dens2.gg

# ggsave(paste0(plots.dir, "/hybridisation_energy.pdf"), mfe.dens2.gg, dpi = 300, width = 5.2, height = 4)

```

# Fig 4 F: Proportion of paired residues

The *paired metric* is a measure that takes into account the ratio of paired residues to non-paired residues (bulges and internal loops) in each duplex. The formula is:

$$
\text{Paired Metric} = \frac{(n_p)*2}{(n_p)*2 + (L_u + R_u)}, \\
\text{ } \\
\text{where:} \\
 n_p = \text{number of paired residues} \\
 L_u = \text{number of unpaired residues left arm} \\
 R_u = \text{number of unpaired residues right arm}
$$

Correct internal loop and bulges positions:

```{r}
utr3_forgi.df <- correct_bulge_positions(utr3_forgi.df)
```

Calculate the percentage of paired residues: 

```{r}
# Calculate paired metric
unpaired.df <- get_unpaired_total(utr3_forgi.df, group = Experiment)
utr3_clusters.df <- left_join(utr3_clusters.df, unpaired.df, by = c("Experiment", c("name" = "id")))

paired_metric.df <- get_paired_metric(utr3_clusters.df, group = Experiment)
utr3_clusters.df <- left_join(utr3_clusters.df, paired_metric.df, by = c("Experiment", "name"))

# Convert to percentage
utr3_clusters.df <- utr3_clusters.df %>%
  ungroup() %>%
  mutate(paired_percentage = paired_to_total_ratio*100) %>%
  dplyr::select(-paired_to_total_ratio)

```

```{r}
paired_percentage_median <- utr3_clusters.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(paired_percentage, na.rm = TRUE))
paired_percentage_median

utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS"))

paired_metric.gg <- ggplot(utr3_clusters.df, aes(x=paired_percentage, color = Experiment)) + 
  geom_density() +
  scale_fill_tableau() +
  scale_color_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "right") +
  ylab("Density") +
  xlab("Paired residues (%)") +
  #ggtitle("3'UTR-3'UTR clusters paired metric") +
  geom_vline(data=paired_percentage_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  facet_grid(rows = vars(span_group))
  #annotate("text", label = paste0("p = ", paired_ratio.pval), x = 80, y = 0.07)

paired_metric.gg

# ggsave(paste0(plots.dir, "/paired_metric.pdf"), paired_metric.gg, dpi = 300, width = 5, height = 4)
```
```{r}
stau1.paired_ratio.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1"  & !str_detect(cluster, "ID"))$paired_percentage
paris.paired_ratio.mfe.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$paired_percentage

paired_ratio.pval <- wilcox.test(stau1.paired_ratio.ls, paris.paired_ratio.mfe.ls)$p.value
paired_ratio.pval
```

```{r}
paired_percentage_median <- utr3_clusters.df %>%
    group_by(Experiment) %>%
    dplyr::summarize(Median = median(paired_percentage, na.rm = TRUE))
paired_percentage_median
```


# Fig S4 B: Number of bulges

```{r}
bulges.df <- utr3_forgi.df %>%
  group_by(Experiment, id) %>%
  dplyr::filter(element_type == "i") %>%
  dplyr::count(element_type) %>%
  dplyr::select(Experiment, id, n) %>%
  ungroup() %>%
  distinct() %>%
  dplyr::rename(bulge_count = n)
```


```{r}
utr3_clusters.df <- left_join(utr3_clusters.df, bulges.df, by = c("Experiment", c("name" = "id")))

utr3_clusters.df <- utr3_clusters.df %>%
  dplyr::select(-L_db, -R_db)

utr3_clusters.df <- utr3_clusters.df %>%
    replace(is.na(.), 0)
```


```{r}
# Wilcox.test
stau1.bulge.ls <- dplyr::filter(utr3_clusters.df, Experiment == "STAU1")$bulge_count
paris.bulge.ls <- dplyr::filter(utr3_clusters.df, Experiment == "PARIS")$bulge_count

median(stau1.bulge.ls)
median(paris.bulge.ls)
mean(stau1.bulge.ls)
mean(paris.bulge.ls)
# wilcox.test(stau1.bulge.ls, paris.bulge.ls, alternative = "two.sided")
```

```{r message=FALSE}
# Boxplot
utr3_clusters.df$Experiment <- factor(utr3_clusters.df$Experiment, levels = c("STAU1", "PARIS"))

bulges.gg <- ggplot(utr3_clusters.df,
                         aes(x = Experiment, y=bulge_count, fill=Experiment)) +
  geom_boxplot(width = 0.5) +
  scale_fill_brewer(palette="Blues") +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  #ggtitle("Bulges per duplex") +
  ylab("Bulges per duplex") +
  ylim(-1.5, 16) +
  facet_grid(cols = vars(factor(span_group, levels = c("long range", "medium range", "short range", "predicted short range")))) +
   geom_label(data = span_counts, aes(label=counts, y = -1.5), label.padding = unit(0.25, "lines"),
            position=position_dodge(width=1.0), inherit.aes = TRUE,  fill = "white", size = 3)
bulges.gg
# ggsave(paste0(plots.dir, "/bulge_count.pdf"), bulges.gg, dpi = 300, width = 5, height = 6)
```

# Fig 4 H: Symmetry classification


The *symmetry classification* is a measure that takes into account the relative position and numbers of bulges and internal loops in each predicted stem-loop structure


#### Proportion of perfect duplexes

```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(stem_type = case_when(paired_percentage == 100 ~ "Perfect duplex",
                               TRUE ~ "Interrupted stem")) %>%
  ungroup()
```

#### Extended symmetry clasification

Description | Label
------------- | -------------
Uninterrupted (no bulges or internal loops on either side) | Perfect duplex
Symmetrical (vertical axis, left-right mirror image) | Symmetric
Balanced (equal number of internal loops of identical sizes on either side, but not all of same size are opposite each other) | Asymmetric
Non-Symmetrical | Asymmetric

Obtain stem symmetry types:

```{r warning=FALSE}
# Get the complete set of internal loop widths for L and R arm 
utr3_forgi.df <- utr3_forgi.df %>%
    replace(is.na(.), 0) 

test <- utr3_forgi.df %>%
  dplyr::group_by(Experiment, id) %>%
  dplyr::filter(element_type == "i") %>%
  summarize(L_i_widths_sorted = paste(sort((L_width)),collapse=","),
            R_i_widths_sorted = paste(sort((R_width)),collapse=","),
            L_i_widths = paste((L_width),collapse=","),
            R_i_widths = paste((R_width),collapse=",")) %>%
  ungroup()

```

```{r}
utr3_clusters.df <- left_join(utr3_clusters.df, test, by = c("Experiment", c("name" = "id")))

symmetry.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(symmetry_type = case_when(stem_type == "Interrupted stem" & L_i_widths == R_i_widths ~ "Symmetric",
                                   stem_type == "Interrupted stem" & L_i_widths != R_i_widths ~ "Asymmetric",
                                   stem_type == "Perfect duplex" ~ "Perfect duplex")) %>%
  ungroup()

unique(symmetry.df$symmetry_type)
stopifnot(nrow(dplyr::filter(symmetry.df, is.na(symmetry_type))) == 0)
```

```{r}
data_counts.df <- symmetry.df %>%
    dplyr::select(name, Experiment, span_group, symmetry_type) %>%
    distinct() %>%
    group_by(Experiment, span_group, symmetry_type) %>%
    summarise(counts = n()) %>%
    arrange(desc(symmetry_type)) %>%
    mutate(percentage = scales::percent(counts / sum(counts), accuracy = 0.01)) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    ungroup() %>%
    group_by(Experiment, span_group) %>%
    mutate(pos = cumsum(percentage) - percentage/2)
  
data_counts.df <- data_counts.df %>%
      mutate(category = symmetry_type)
```

```{r}
bar = ggplot() + 
    geom_bar(aes(y = percentage, x = "", fill = category), data = data_counts.df,
                            stat="identity", width = 0.5) + # color="black"
    ggrepel::geom_text_repel(data = data_counts.df, aes(x = "", y = pos, label=paste0(round(percentage, 1),"%")), size = 3, nudge_x = 0.4,segment.size = 0.5, segment.color = '#515A5A') + # label=paste0(round(percentage, 2),"%"))
    facet_grid(cols = vars(span_group), rows = vars(factor(Experiment, levels = c("STAU1", "PARIS")))) +
    #facet_wrap(. ~ Experiment, scales = "free") +
    scale_fill_brewer(palette = "PuBuGn") +
    theme(legend.position="right", legend.direction="vertical",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") +
    theme_minimal_grid()

bar
# ggsave(paste0(plots.dir, "/symmetry.pdf"), bar, dpi = 300, width = 7, height = 4)
```

***
> Symmetry incl "Balanced"

```{r}
symmetry2.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(symmetry_type = case_when(stem_type == "Interrupted stem" & L_i_widths == R_i_widths ~ "Symmetric",
                                   stem_type == "Interrupted stem" & L_i_widths_sorted != R_i_widths_sorted & L_i_widths != R_i_widths ~ "Asymmetric",
                                   stem_type == "Interrupted stem" & L_i_widths != R_i_widths & L_i_widths_sorted == R_i_widths_sorted ~ "Balanced",
                                   stem_type == "Perfect duplex" ~ "Perfect duplex")) %>%
  ungroup()

data_counts2.df <- symmetry2.df %>%
    dplyr::select(name, Experiment, span_group, symmetry_type) %>%
    distinct() %>%
    group_by(Experiment, span_group, symmetry_type) %>%
    summarise(counts = n()) %>%
    arrange(desc(symmetry_type)) %>%
    mutate(percentage = scales::percent(counts / sum(counts), accuracy = 0.01)) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    ungroup() %>%
    group_by(Experiment, span_group) %>%
    mutate(pos = cumsum(percentage) - percentage/2)
  
data_counts2.df <- data_counts2.df %>%
    mutate(category = symmetry_type)

  
  bar2 = ggplot() + 
    geom_bar(aes(y = percentage, x = "", fill = category), data = data_counts2.df,
                            stat="identity", width = 0.5) +
    ggrepel::geom_text_repel(data = data_counts.df, aes(x = "", y = pos, label=paste0(round(percentage, 1),"%")), size=3, nudge_x = 0.4,
                                 segment.size = 0.5, segment.color = '#515A5A') + # label=paste0(round(percentage, 2),"%"))
    facet_grid(cols = vars(span_group), rows = vars(Experiment)) +
    #facet_wrap(. ~ Experiment, scales = "free") +
    scale_fill_brewer(palette = "PuBuGn") +
    theme(legend.position="right", legend.direction="vertical",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") +
    theme_minimal()

bar2
```

# Extras/ scraps

***
> GC Pairs

```{r}
utr3_clusters.df <- utr3_clusters.df %>%
  mutate(id = paste(Experiment, name, sep = "-"))

paired_res.df <- utr3_clusters.df %>%
  rowwise() %>%
  mutate(paired_res = list(get_paired_residues(id, L_db, L_sequence, R_db, R_sequence))) %>%
  mutate(L_paired_residues = paired_res$l_paired_residues,
         R_paired_residues = paired_res$r_paired_residues) %>%
  ungroup() %>%
  dplyr::select(-paired_res)

paired_res.df <- get_gc_pairs(paired_res.df)
# fwrite(paired_res.df, "~/Desktop/stau1_paris_gc.tsv.gz", sep ="\t")
```

```{r}
gc_median <- paired_res.df %>%
    group_by(Experiment) %>%
    dplyr::summarize(Median = median(GC_percentage, na.rm=TRUE))
gc_median

gc_pairs.gg <- ggplot(paired_res.df, aes(x = GC_percentage, color = Experiment)) + 
  geom_density(alpha = 0.8, adjust = 1.5) +
  #scale_x_log10() + annotation_logticks() +
  scale_color_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Density") +
  xlab("G:C and C:G pairs (%) ") +
  geom_vline(data=gc_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") 
gc_pairs.gg
# ggsave(paste0(plots.dir, "/gc_percentage.pdf"), duplex_span.gg, dpi = 300, width = 4, height = 4)

```
```{r}
gc_median <- paired_res.df %>%
    group_by(Experiment, span_group) %>%
    dplyr::summarize(Median = median(GC_percentage, na.rm=TRUE))
gc_median

gc_pairs.gg <- ggplot(paired_res.df, aes(x = GC_percentage, color = Experiment)) + 
  geom_density(alpha = 0.8, adjust = 1.5) +
  #scale_x_log10() + annotation_logticks() +
  scale_color_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Density") +
  xlab("G:C and C:G pairs (%) ") +
  geom_vline(data=gc_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed") +
  facet_grid(rows = vars(span_group))

gc_pairs.gg
```

```{r}
gc_median <- paired_res.df %>%
    group_by(Experiment) %>%
    dplyr::summarize(Median = median(GC_pos_count, na.rm=TRUE))
gc_median

gc_pairs.gg <- ggplot(paired_res.df, aes(x = GC_pos_count, color = Experiment)) + 
  geom_density(alpha = 0.8, adjust = 1.7) +
  #scale_x_log10() + annotation_logticks() +
  scale_color_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  ylab("Density") +
  xlab("Number of G:C/C:G pairs") +
  geom_vline(data=gc_median, aes(xintercept=Median, color=Experiment),
             linetype="dashed")

gc_pairs.gg
# ggsave(paste0(plots.dir, "/gc_percentage.pdf"), duplex_span.gg, dpi = 300, width = 4, height = 4)


```

***
> Bulge spacing

The spacing between bulges is the width of stems between bulges

```{r}
bulge_spacing.df <- utr3_forgi.df %>%
  ungroup() %>%
  group_by(Experiment, id) %>%
  dplyr::filter(any(element_type =="i")) %>%
  dplyr::filter(element_type == "s") %>%
  dplyr::filter(!element == "s0") %>%
  dplyr::filter(!element_number == max(element_number))
```

Calculate median spacing per structure

```{r}
median_bulge_spacing.df <- bulge_spacing.df %>% 
  summarise(bulge_spacing_median=median(L_width), .groups = "keep")
```


```{r message=FALSE}
# Boxplot
bulge_s.gg <- ggplot(median_bulge_spacing.df,
                         aes(x = Experiment, y=bulge_spacing_median, fill=Experiment)) +
  geom_boxplot() +
  scale_fill_brewer(palette="Blues") +
  theme(legend.position="right", legend.direction="vertical") +
  scale_fill_tableau() +
  theme_minimal_grid() + 
  theme(legend.position = "top") +
  #ggtitle("Bulges per duplex") +
  ylab("Median spacing between bulges (nt)") 
  # geom_label(data = utr3_counts.df, aes(label=paste0("n = ",counts), y = -1.5), label.padding = unit(0.25, "lines"),
  #           position=position_dodge(width=1.0), inherit.aes = TRUE,  fill = "white", size = 6)
bulge_s.gg
# ggsave(paste0(plots.dir, "/bulge_spacing.pdf"), bulge_s.gg, dpi = 300, width = 4, height = 6)
```


***
> Sequence content

Calculate the nucleotide frequency for the paired residues in each dataset

```{r}
utr3_clusters.df <- get_nucleotide_frequency(utr3_clusters.df)
utr3_clusters.df <- utr3_clusters.df %>%
    dplyr::arrange(desc(Experiment), desc(total_paired))
```

Plot nucleotide frequency 

ID = 1 - largest bp
Short duplexes display higher GC content and long duplexes showed higher AU content, for both PARIS and STAU1.

```{r}
nuc_freq.gg <- plot_nucleotide_frequency(utr3_clusters.df)$plot +
  ggtitle("Nucleotide frequencies in each arm")

nuc_freq.gg
# ggsave(paste0(data.dir, "nuc_freq.pdf"), nuc_freq.gg, dpi = 300, width = 4, height = 7)
```

```{r}
nuc_freq.gg
```

***
> Non-normalised MFE

```{r}

# utr3_clusters_mfe2.df <- pivot_longer(utr3_clusters.df, cols = c(mfe, mean_shuffled_mfe), names_to = "Sample", values_to = "MFE")
# 
# utr3_clusters_mfe2.df <- utr3_clusters_mfe2.df %>%
#   mutate(Sample = case_when((Sample == "mfe") ~ "STAU1",
#                             (Sample == "mean_shuffled_mfe") ~ "Shuffled control"))
# 
# mfe_median3 <- utr3_clusters.df %>%
#     group_by(Experiment, span_group) %>%
#     dplyr::summarize(Median = median(mfe, na.rm = TRUE))
# mfe_median
# 
# mfe.dens3.gg <- ggplot(utr3_clusters_mfe2.df, aes(x = MFE, linetype = Sample, color = Experiment)) + 
#   geom_density(alpha = 0.8) +
#   #annotate("text", label = "p < 2.2e-16", x = -1, y = 1.7) +
#   scale_linetype_manual(values=c("longdash", "solid")) +
#   scale_color_tableau() +
#   theme_minimal_grid() + 
#   facet_grid(rows = vars(Experiment), cols = vars(span_group)) +
#   theme(legend.position = "top") +
#   ylab("Density") +
#   xlab("Normalised hybridisation energy (kcal/mol)/bp") +
#   geom_vline(data=mfe_median3, aes(xintercept=Median, color=Experiment),
#              linetype="dashed") 
# 
# mfe.dens3.gg

```

