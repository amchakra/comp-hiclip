---
title: "Figure 3 & related"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

#### Libraries

```{r include=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(Biostrings))
suppressPackageStartupMessages(library(rematch))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(broom))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(cluster))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(tidyverse, warn.conflicts = FALSE))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(primavera))
suppressPackageStartupMessages(library(GenomicFeatures))
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(UpSetR))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(gginnards))
suppressPackageStartupMessages(library(factoextra))
theme_set(theme_bw() +
            theme(legend.position = "top"))
```

```{r}
library(BSgenome.Hsapiens.UCSC.hg38)
Hsapiens <- BSgenome.Hsapiens.UCSC.hg38
```

#### Functions: metaprofiles and clustering

```{r}
convert_probability <- function(x, na.rm = FALSE) (1 - x)

get_sem <- function(x) sd(x)/sqrt(length(x))

get_metaprofile_mean <- function(filename) {
  
  prob.df <- read.csv(filename, sep="\t")
  colnames(prob.df) <- seq(1:ncol(prob.df)) - (ncol(prob.df)+1)/2
  prob.df <- drop_na(prob.df, 0) # remove peaks sites with NAs at the xl site
  
  # Convert unpaired probability to paired probability
  prob.df <- prob.df %>%
  mutate_if(is.numeric, convert_probability)
  
  prob.mean <- prob.df %>% 
    summarise(across(where(is.numeric), mean))
  prob.sd <- prob.df %>% 
    summarise(across(where(is.numeric), get_sem))
  prob.mean <- as.data.frame(t(prob.mean))
  colnames(prob.mean) <- "mean_prob"
  prob.sd <- as.data.frame(t(prob.sd))
  colnames(prob.sd) <- "std_prob"
  df <- cbind(prob.mean, prob.sd)
  df <- rownames_to_column(df, var = "pos")
  
  return(df)
  
}

run_kmeans <- function(data, k) {
  
  set.seed(123)
  data.kmeans <- kmeans(data, centers = k, iter.max = 30)
  data <- augment(data.kmeans, data) #%>% arrange(.cluster)
  data <- data %>% add_count(.cluster, name = "cluster_size") %>%
    column_to_rownames(var = ".rownames")
  
  return(data)
  
}
```

#### Functions: plotting

```{r}
plot_metaprofile <- function(data.df) {
  
  profile.gg <- ggplot(data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
    geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob)), color = "grey80", fill = "grey80") +
    geom_line(aes(linetype = Sample)) +
    scale_linetype_manual(values=c("longdash", "solid")) +
    scale_color_manual(values=c('#E69F00', '#222222')) +
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    ylim(c(0.40, 0.60)) +
    xlab("Distance relative to the peak start (nt)") +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Mean probability") +
    labs(linetype = "Sample") +
    geom_text(aes(x = 55,y = 0.60,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 4)
  
  return(profile.gg)
  
}


plot_cluster_heatmap <- function(cluster.df, plot.title, plot.name) {
  
  cluster.df <- cluster.df %>% arrange(.cluster)
  clust.mx = as.matrix(dplyr::select(cluster.df, -c(.cluster, cluster_size))) # get numeric matrix
  annotation.df <- dplyr::select(cluster.df, .cluster)
  gaps_row = cumsum(unique(cluster.df$cluster_size))
  mat_colors <- list(group = col_pal)
  names(mat_colors$group) <- unique(annotation.df$.cluster)
  heatmap <- pheatmap(clust.mx,cluster_cols = FALSE, cluster_rows = FALSE, show_rownames = FALSE,
                      color = mako(200),
                      gaps_row = gaps_row, fontsize_col = 3.5, annotation_row = annotation.df, border_color = FALSE,
                      annotation_colors = list(.cluster = mat_colors$group), angle_col = "45",
                      main = plot.title, filename = plot.name)
  return(heatmap)
  
}

# cl = dataframe containing nt position probabilities +  a "cluster" column and a "cluster_size" column
plot_cluster_mean <- function(cl, left_flank) {
  
  clust.m <- melt(cl)
  clust.mean <- dcast(clust.m, cluster ~ variable, mean)
  
  clust.mean.m <- melt(clust.mean, id=c("cluster","cluster_size")) # arrange the df to long format for facet_wrap plotting
  
  clust.mean.profiles <- ggplot(data = clust.mean.m, aes(x = as.numeric(variable)-left_flank, y = value, color=cluster)) +
    geom_line() +
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    geom_hline(yintercept = 0.5, linetype = "dashed", color ="grey84", size = 0.5) +
    facet_wrap(~ cluster, ncol = 1, scales = "free_x") +   #scales = "free_y"
    xlab("Distance relative to the peak start (nt)") +
    ylab("Mean probability")+
    scale_color_manual(values = col_pal)+
    theme(text = element_text(size=14),
          strip.text = element_text(size=10, face = "bold"),
          plot.title = element_text(size = 14, face = "bold"),
          axis.text.x = element_text(angle = 60, hjust = 1)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
  # rename legend title and add the number of observations in each cluster:
  clust.mean.profiles <- clust.mean.profiles +
    guides(color=guide_legend(title='Cluster')) +
    geom_text(data=clust.mean, aes(x=20,y=0.74,label=paste0("n = ",cluster_size)), inherit.aes=FALSE, size=3)
  
  return(clust.mean.profiles)
  
}


plot_stacked_barchart <- function(data.df, column, group=NULL) {
  
  data_counts.df <- data.df %>%
    dplyr::select(id, {{group}}, {{column}}) %>%
    distinct() %>%
    group_by({{group}}, {{column}}) %>%
    summarise(counts = n()) %>%
    arrange(desc({{column}})) %>%
    mutate(percentage = scales::percent(counts / sum(counts))) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
    mutate(pos = cumsum(percentage) - percentage/2)
  
  bar = ggplot() + geom_bar(aes(y = percentage, x = "", fill = {{column}}), data = data_counts.df,
                            stat="identity", width = 0.5) +
    ggrepel::geom_text_repel(data = data_counts.df, aes(x = "", y = pos, label = paste0(round(percentage,1),"%")), size=5, nudge_x = 0.4,
                                 segment.size = 0.5, segment.color = '#515A5A') +
    facet_grid(cols = vars({{group}})) +
    #paletteer::scale_fill_paletteer_d("rcartocolor::Earth", direction = -1) +
    theme(legend.position="right", legend.direction="vertical",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") +
    theme_minimal()
  
  return(list(plot = bar, data = data_counts.df))
  
}

```

#### Functions: defining duplexes from RNAplfold clusters

```{r}
get_duplex <- function(region.dt, cluster_number, cores = 4) {

  # Cluster 1 = 1-30 & 30-50
  # Cluster 2 = 8-36 & 36-63
  # Cluster 3 = 16-44 & 44-68
  
  if(cluster_number == 1) {
    
    c.L_start <- 1
    c.L_end <- 30
    c.R_start <- 31
    c.R_end <- 50
    
  } else if(cluster_number == 2) {
    
    c.L_start <- 8
    c.L_end <- 36
    c.R_start <- 37
    c.R_end <- 63    
    
  } else if(cluster_number == 3) {
    
    c.L_start <- 16
    c.L_end <- 44
    c.R_start <- 45
    c.R_end <- 68     
    
  } else {
    
    stop("cluster_number should be 1, 2, or 3")
    
  }
    
  c.dt <- region.dt[cluster == cluster_number]
  
  c.dt[strand == "+", 
        `:=` (L_start = xlink + c.L_start,
              L_end = xlink + c.L_end,
              R_start = xlink + c.R_start,
              R_end = xlink + c.R_end)]
  c.dt[strand == "-", 
        `:=` (L_end = xlink - c.L_start,
              L_start = xlink - c.L_end,
              R_end = xlink - c.R_start,
              R_start = xlink - c.R_end)] # start and end flipped for GRanges
  
  L.gr <- with(c.dt, GRanges(seqnames = seqnames,
                              ranges = IRanges(start = L_start, end = L_end),
                              strand = strand,
                              name = name,
                              score = score,
                              cluster = cluster,
                              xlink = xlink))
  
  R.gr <- with(c.dt, GRanges(seqnames = seqnames,
                              ranges = IRanges(start = R_start, end = R_end),
                              strand = strand,
                              name = name,
                              score = score,
                              cluster = cluster,
                              xlink = xlink))
  
  L.gr$seq <- as.character(getSeq(Hsapiens, L.gr))
  R.gr$seq <- as.character(getSeq(Hsapiens, R.gr))
  
  c.duplex.l <- mclapply(seq_along(L.gr), 
                         function(peak) analyse_structure(L.gr$name[peak], L.gr$seq[peak], R.gr$seq[peak]),
                         mc.cores = cores)
  
  c.duplex.dt <- rbindlist(c.duplex.l)
  c.duplex.dt <- merge(c.dt, c.duplex.dt, by = "name")
  c.duplex.dt$loop <- str_count(str_extract(c.duplex.dt$structure, "\\.*&\\.*"), "\\.")
  
  return(c.duplex.dt)
  
}

```


#### Functions: hybrids clustering

```{r}
resize_peaks <- function(bedfiles.list, left = 100, right = 100) {
  
  w <- left + right + 1  # width of interval: xl site + flanks
  
  grl <- GRangesList(lapply(bedfiles.list, import.bed))
  gr <- unlist(grl)
  gr <- keepStandardChromosomes(gr, pruning.mode = "coarse")
  gr <- dropSeqlevels(gr, c("chrM", "chrY"), pruning.mode = "coarse")
  
  gr <- resize(gr, width = 1, fix = "start") # resize the peaks, start of peak = 1
  gr <- unique(gr)  # keep unique xl positions
  gr <- resize(resize(gr, width = right + 1, fix = "start"), width = w, fix = "end") # add +/- flanks
  gr$id <- paste0("ID", seq(1, length(gr)))
  
  return(gr)
  
}


merge_by_partial_string <- function(df1, df2) {
  
  df1$matchID = row.names(df1)
  df2$matchID = sapply(df2$gene_name, function(x) grep(x, df1$fasta_id)) # not very fast but ok
  
  df_merge = merge(df1, df2, by = "matchID")[-1]
  
  return(df_merge)
}

```

```{r}
get_paired_regions <- function(id, L_db, R_db) {
  
  l_brackets <- str_locate_all(L_db, pattern = "\\(")[[1]][,1]
  l_start <- l_brackets[1]
  l_end <- l_brackets[length(l_brackets)]
  
  r_brackets <- str_locate_all(R_db, pattern = "\\)")[[1]][,1]
  r_start <- r_brackets[1]
  r_end <- r_brackets[length(r_brackets)]
  
  stopifnot(length(l_brackets) == length(r_brackets)) # check L and R arms of the duplex have an equal number of bp
  
  results.ls <- list(id = id, l_start = l_start, l_end = l_end, 
                     r_start=r_start, r_end=r_end)
  
  return(results.ls)
  
}
```

```{r}
get_stem_loop_sequence <- function(hybrids.dt, genome.dt) {
  
  hybrids.dt[, gene_id := L_seqnames]
  setkey(genome.dt, gene_id)
  setkey(hybrids.dt, gene_id)
  
  seq.dt <- genome.dt[hybrids.dt]
  seq.dt[, `:=`(stem_loop_sequence, stringr::str_sub(sequence, start = L_start, end = R_end))]
  seq.dt[, `:=`(c("gene_id", "sequence"), NULL)]

  return(seq.dt)
}
```


#### Data

***
> Data directories

```{r}
data.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/short_range/xl_plus_100/sept_2021"
plots.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/plots/figure_3"
ref.dir <- "~/Dropbox (The Francis Crick)/comp_hiclip/ref"
ref.dir2 <- "/Users/iosubi/Documents/projects/computational_hiCLIP/newest_datasets"
```

***
> Annotations

```{r warning=FALSE}
txdb <- paste0(ref.dir,"/gencode.v33.txdb.sqlite")
gencode.txdb <- AnnotationDbi::loadDb(txdb)
human.gtf <- paste0(ref.dir, "/GRCh38.gencode_v33.tx.gtf.gz") # contains fasta_id used by Tosca
regions.gr <- import.gff2(paste0(ref.dir,"/regions.gtf.gz"))
genes.gr <- import.gff2(paste0(ref.dir, "/GRCh38.gencode_v33.tx.gtf.gz"))
fa.dss <- readDNAStringSet((paste0(ref.dir2, "/GRCh38.gencode_v33.fa")))
```

***
> Probablility profiles

```{r}
prob.files <- list.files(paste0(data.dir,""), pattern = "_prob_profiles.tsv.gz", full.names = TRUE)
shuff.files <- prob.files[str_detect(prob.files, "shuffled")]
prob.files <- prob.files[!str_detect(prob.files, "shuffled")]
shuffled <- TRUE

prob.files
shuff.files
```

***
> Hybrids data

```{r}
# Linker
linker.dt <- fread("/Users/iosubi/Documents/projects/computational_hiCLIP/newest_datasets/linker/linker.clusters.mfe.tsv.gz")

# No linker
nolinker.dt <- fread("/Users/iosubi/Documents/projects/computational_hiCLIP/newest_datasets/nolinker/all.hybrids.tsv.gz")
nolinker.dt[, sample := tstrsplit(sample, "\\.")[[1]]]
```

***
> Annotated peaks

```{r}
bed.files <- list.files(path = paste0(data.dir,""), pattern = "annot.bed.gz", full.names = TRUE)
stau1.bedfile <- bed.files[str_detect(bed.files, "stau1")]
print(stau1.bedfile)
```



# Main figure

## Fig 3 A

### STAU1 nonhybrid regional distribution

```{r}
peaks.gr <- import.bed(stau1.bedfile)
peaks.gr <- keepStandardChromosomes(peaks.gr, pruning.mode = "coarse")
peaks.gr <- dropSeqlevels(peaks.gr, c("chrM", "chrY"), pruning.mode = "coarse")
```

```{r}
peaks.gr
```

```{r}
# Get region type
overlap <- findOverlaps(peaks.gr, regions.gr)
regions.gr$type <- as.character(regions.gr$type)

peaks.gr$type <- as.character(NA)
peaks.gr[queryHits(overlap)]$type <- regions.gr[subjectHits(overlap)]$type

peak_regions.df <- as.data.frame(peaks.gr)
peak_regions.df$id <- rownames(peak_regions.df)

peak_regions.df$type <- factor(peak_regions.df$type, levels = c("UTR5", "CDS", "intron", "UTR3", "ncRNA"))
```



```{r}
region_colours <- c("ncRNA" = "#fbb04e", "intron" = "#bfbb60", "UTR5" = "#a2ceaa",
                    "rRNA" = "#4f6980", "UTR3" = "#f47942", "CDS" = "#638b66",
                    "tRNA" = "#849db1")

peak_regions.gg <- plot_stacked_barchart(peak_regions.df, column = type)$plot +
  guides(fill=guide_legend(title="Region")) +
  theme_minimal_grid() + 
  scale_fill_manual(values = region_colours) +
  theme(legend.position = "top") +
  scale_y_continuous(position = "right") +
  coord_flip()
  #  geom_text(data = peak_regions.df, aes(x = 0.65, y = 90, label = paste0("n = ", nrow(peak_regions.df))), inherit.aes = FALSE, size = 6) 
  
peak_regions.gg
ggsave(paste0(plots.dir, "/stau1_peak_regions.pdf"), peak_regions.gg, width = 8, height = 3)
```

### STAU1 unpaired probability metaprofile

```{r}
prob.file <- prob.files[str_detect(prob.files, "stau1")]
shuff.file <- shuff.files[str_detect(prob.files, "stau1")]
prob.name <- str_split(prob.file, pattern = "\\/")[[1]]
prob.name <- prob.name[length(prob.name)]
prob.name <- str_to_upper(str_split(prob.name, pattern = "_")[[1]][1]) #RBP name

prefix <- basename(prob.file)
prefix <- str_split(prefix, ".tsv")[[1]][1]
print(prefix)
```

```{r}
# Load metaprofile dataframes (df output from get_structure_metaprofile.R)
stau1.prob.df <- fread(prob.file, skip = 1, data.table = FALSE)
stau1.prob.df <- column_to_rownames(stau1.prob.df, var = "V1")
colnames(stau1.prob.df) <- seq(1-(ncol(stau1.prob.df)+1)/2, (ncol(stau1.prob.df)-1)/2) # center column names on zero
stau1.prob.df <- drop_na(stau1.prob.df)
```

```{r}
stau1.prob.mean.df <- get_metaprofile_mean(prob.file)
stau1.prob.mean.df$Sample <- prob.name

if (shuffled == TRUE) {

  stau1.shuff.mean.df <- get_metaprofile_mean(shuff.file)
  stau1.shuff.mean.df$Sample <- "Control (shuffled)"
  stau1.data.df <- rbind(stau1.prob.mean.df, stau1.shuff.mean.df)
  stau1.data.df$peaks_count <- nrow(stau1.prob.df)
  
} else {
  stau1.data.df <- stau1.prob.mean.df
  stau1.data.df$peaks_count <- nrow(stau1.prob.df)
}
```


```{r}
# plot the mean probability and standard error of the mean
stau1.profile.gg <- plot_metaprofile(stau1.data.df)
stau1.profile.gg <- append_layers(stau1.profile.gg, annotate("rect", xmin = 10, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.3, fill = "#31a1b3"), position = "bottom")

stau1.profile.gg
# ggsave(paste0(plots.dir,"/",prefix,"_metaprofile_paired.pdf"), stau1.profile.gg, width = 4, height = 4, dpi = 300)
```

## Fig 3 B

### STAU1 unpaired probability clusters

```{r}
# ==========
# K-means clustering
# ==========
# Focus on the -50 to +75 nt relative to peak starts:
stau1.prob.df <- stau1.prob.df %>% dplyr::select("-50":"75")

# Convert unpaired probablity to paired probability
stau1.prob.df <- stau1.prob.df %>%
  mutate_if(is.numeric, convert_probability)

# Focus on the +10 to +75 nt relative to peak starts:
prob_downstream.df <- stau1.prob.df %>% dplyr::select("10":"75")
```

Find the optimal number of clusters

```{r}
set.seed(123)
silhouette.gg <- fviz_nbclust(prob_downstream.df, run_kmeans, method="silhouette")
silhouette.gg
# ggsave(paste0(plots.dir,"/silhouette_2k.pdf"), silhouette.gg, dpi = 300, width = 4, height = 4)
```

```{r}
n_clusters <- 2
```

Number of clusters for K-means clustering: `{r} n_clusters`

```{r}
# K-means clustering - "euclidean" dist, 2 clusters
set.seed(123)
kmeans.df <- run_kmeans(prob_downstream.df, n_clusters)
```

```{r warning=FALSE, message=FALSE}
# join cluster information to the data containing the -50: +75 nt positions 
stopifnot(rownames(kmeans.df) == rownames(stau1.prob.df))
stau1.prob.df$cluster <- kmeans.df$.cluster # match cluster assignment to the prob.df
stau1.prob.df$cluster_size <- kmeans.df$cluster_size
```

```{r warning=FALSE, message=FALSE}
stau1.prob.df$cluster <- plyr::mapvalues(stau1.prob.df$cluster, from=c(1, 2), to=c(0, 1))
stau1.prob.df <- dplyr::arrange(stau1.prob.df, cluster)
stau1.prob.df$cluster <- factor(stau1.prob.df$cluster, levels = c(0, 1))
```

```{r warning=FALSE, message=FALSE}
col_pal <- brewer.pal(n_clusters, "Dark2")
clusters.gg <- plot_cluster_mean(stau1.prob.df, 51)
clusters.gg
```

```{r}
# Subcluster cluster 1
cluster1.df <- stau1.prob.df %>%
  dplyr::filter(cluster == 1) %>%
  dplyr::select(-cluster, -cluster_size) 

# Focus on the +10 to +75 nt relative to peak starts:
cluster1.df_downstream.df <- cluster1.df %>%
  dplyr::select("10":"75")

# Find the optimal number of clusters.
set.seed(123)
silhouette_cl1.gg <- fviz_nbclust(cluster1.df_downstream.df, run_kmeans, method="silhouette")
silhouette_cl1.gg
# ggsave(paste0(plots.dir,"/silhouette_cluster1.pdf"), silhouette_cl1.gg, dpi = 300, width = 4, height = 4)
```

```{r}
# K-means clustering - "euclidean" dist, 3 clusters
set.seed(123)
kmeans.df <- run_kmeans(cluster1.df_downstream.df, 3)
# join cluster information to the data containing the -50: +75 nt positions 
stopifnot(rownames(kmeans.df) == rownames(cluster1.df))
cluster1.df$cluster <- kmeans.df$.cluster # match cluster assignment to the prob.df
cluster1.df$cluster_size <- kmeans.df$cluster_size
```

```{r}
cluster1.df$cluster <- plyr::mapvalues(cluster1.df$cluster, from = c(3, 2, 1), to = c(3, 1, 2))
cluster1.df$cluster <- factor(cluster1.df$cluster, levels = c(1, 2, 3))

cluster1.df <- cluster1.df %>%
  dplyr::rename(.cluster = cluster)
```

```{r}
# Select cluster 0 and join
cluster0.df <- stau1.prob.df %>%
  dplyr::filter(cluster == "0") %>%
  dplyr::rename(.cluster = cluster)
```


```{r}
# Merge back cluster 0 and the subclusters of cluster 1
clusters.df <- rbind(cluster0.df, cluster1.df)
clusters.df$.cluster <- plyr::mapvalues(clusters.df$.cluster, from = c(3, 2, 1, 0), to = c(1, 2, 3, 0))
clusters.df$.cluster <- factor(clusters.df$.cluster, levels = c(0, 1, 2, 3))

stopifnot(nrow(stau1.prob.df) == nrow(clusters.df)) # Check same size as original prob df
```

```{r}
col_pal <- brewer.pal(4, "Dark2")
plot_cluster_heatmap(clusters.df, plot.title = prob.name, plot.name = paste0(plots.dir,"/",prefix,"_kmeans_minus50_paired_4clusters.png"))
```

```{r}
# Export clusters data
clusters.df <- rownames_to_column(clusters.df, var = "id")
#fwrite(clusters.df, paste0(data.dir, "/", prefix,"_clusters.tsv.gz"), sep = "\t")
```

Metaprofiles for each cluster: 

```{r warning=FALSE, message=FALSE}
clusters.df <- clusters.df %>%
  dplyr::rename(cluster = .cluster)
```


```{r warning=FALSE, message=FALSE}
col_pal <- brewer.pal(4, "Dark2")

clusters.gg <- plot_cluster_mean(clusters.df, 51) +
  scale_y_continuous(position = "right") +
  theme(strip.background = element_blank(), strip.text.x = element_blank())
clusters.gg <- append_layers(clusters.gg, annotate("rect", xmin = 10, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.3, fill = "#31a1b3"), position = "bottom")

clusters.gg
ggsave(paste0(plots.dir,"/",prefix,"_cluster_profiles.pdf"), clusters.gg, width = 3, height = 10)

```

Clusters 1,2,3 contain structures with higher paired probability downstream the xlink site, suggesting the presence of putative stems.

### Define duplex arms

```{r}
dt <- as.data.table(clusters.df[.cluster != 0])

p.list <- lapply(1:3, function(i) {
  
  message(i)
  
  m <- colMeans(dt[.cluster == i, .SD, .SDcols = !c("id", ".cluster", "cluster_size")])
  lmin <- which(diff(sign(diff(m))) == 2) + 1 -51
  lmin <- lmin[lmin > 0]
  names(lmin) <- NULL
  print(lmin)
  
  p <- ggplot(data = data.frame(coord = as.integer(names(m)), score = m), aes(x = coord, y = score)) +
    geom_line() +
    geom_vline(xintercept = lmin, linetype = "dashed", colour = "blue") +
    theme_minimal_grid() +
    labs(x = "Coordinate",
         y = "Mean pairing probability",
         title = paste("Cluster", i))
  
  return(p)
  
})

ggsave(plot_grid(plotlist = p.list, ncol = 1), filename = file.path(plot.path, "sr_clusters_lmin.pdf"), width = 7, height = 10)

# ==========
# Identify duplexes within arms
# ==========

peaks.dt <- as.data.table(import.bed("~/Dropbox (The Francis Crick)/comp_hiclip/short_range/xl_plus_100/sept_2021/stau1.10nt_10nt.peaks.annot_id.bed.gz"))
peaks.dt <- merge(peaks.dt, dt[, .(id, .cluster)], by.x = "name", by.y = "id")
setnames(peaks.dt, ".cluster", "cluster")
peaks.dt[, xlink := start + 101]



cluster.duplexes.l <- lapply(1:3, function(i) get_duplex(region.dt = peaks.dt,
                                                         cluster_number = i))
cluster.duplexes.dt <- rbindlist(cluster.duplexes.l)
fwrite(cluster.duplexes.dt, "~/Dropbox (The Francis Crick)/comp_hiclip/short_range/xl_plus_100/sept_2021/short_range_lmin_rnaduplex_structures.tsv.gz", sep = "\t")

```


## Fig 3 C

### Structure analyses

Use peaks (IDs) in clusters 1, 2 and 3.

The short range duplexes were used using the local minima approach applied on each of clusters 1-3.

There are `r length(unique(cluster.duplexes.dt$name))` peaks in clusters 1,2,3.

```{r}
nrow(cluster.duplexes.dt)
```

#### Trim dot bracket structure to focus only on the paired regions


```{r}
# Trim unpaired residues at the ends of left and right arms

# Separate L_db and R_db
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  separate(structure, into = c("L_db", "R_db"), sep = "&", remove = FALSE)

# Get positions of paired residues within structures of each arm
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  rowwise() %>%
  mutate(paired_regions = list(get_paired_regions(id, L_db, R_db))) %>%
  mutate(L_duplex_start= paired_regions$l_start, 
         L_duplex_end = paired_regions$l_end,
         R_duplex_start= paired_regions$r_start, 
         R_duplex_end = paired_regions$r_end) %>%
  ungroup() %>%
  dplyr::select(-paired_regions)

# Adjust genomic coordinates to contain only the paired region
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  rowwise() %>%
  mutate(L_genomic_start = case_when(strand == "+" ~ L_start + L_duplex_start - 1,
                                    TRUE ~ L_end - L_duplex_end + 1),
         L_genomic_end = case_when(strand == "+" ~ L_start + L_duplex_end - 1,
                                  TRUE ~ L_end - L_duplex_start + 1),
         R_genomic_start = case_when(strand == "+" ~ R_start + R_duplex_start - 1,
                                    TRUE ~ R_end - R_duplex_end + 1),
         R_genomic_end = case_when(strand == "+" ~ R_start + R_duplex_end - 1,
                                  TRUE ~ R_end - R_duplex_start + 1)) %>%
  mutate(hairpin_loop = case_when(strand == "+" ~ R_genomic_start - L_genomic_end + 1 - 2,
                                  TRUE ~ L_genomic_start - R_genomic_end + 1 - 2)) %>%
  ungroup()


cluster.duplexes.dt <- dplyr::filter(cluster.duplexes.dt, loop != 0)
```

## Fig 3 D

### Hairpin loop size

```{r}
hairpin_median <- cluster.duplexes.dt %>%
  dplyr::summarize(Median = median(hairpin_loop, na.rm = TRUE))
hairpin_median

# Plot
h0.gg <- ggplot(cluster.duplexes.dt, aes(x = hairpin_loop)) + 
  #geom_histogram(bins = 45, color="black", fill = "#DEEBF7") +
  geom_density(color = "#31a1b3", bw = 0.1) +
  theme_minimal_grid() +
  geom_vline(data=hairpin_median, aes(xintercept=Median), color = "grey",
             linetype="dashed") +
  scale_x_log10() + annotation_logticks(sides = "b") + #breaks=c(3,5,7, 10,30))
  # ggtitle("Distribution of hairpin loop sizes") +
  xlab("Hairpin loop size (nt)") +
  ylab("Density")

h0.gg
# ggsave(paste0(plots.dir,"/",prefix,"_hairpin_lengths.pdf"), h0.gg, width = 5, height = 4)
```

```{r}
quantile(cluster.duplexes.dt$hairpin_loop, c(.25, .50, .75, 1))
```

## Fig 3 E

### Overlap with duplexes from STAU1 hybrid reads

***
> Convert coordinates to tx

#### Get genomic and tx coordinates for the resized peaks that have been used for RNAplfold

```{r}
# ==========
# Prepare gene IDs and coordinates
# ==========

# Load peaks data, resize exactly as for rnaplfold used to predict structures
peaks.gc.gr <- resize_peaks(stau1.bedfile, left = 100, right = 100)
```


```{r}
# Save a record of the bed fie
peaks.id.gr <- peaks.gc.gr
peaks.id.gr$name <- peaks.id.gr$id
peaks.id.gr$id <- NULL

#export.bed(peaks.id.gr, paste0(data.dir, "/stau1.10nt_10nt.peaks.annot_id.bed.gz"))
```


```{r}
# Add a new column containing gene ids by directly mapping the transcript ids
keys = peaks.gc.gr$name
mapped.ids <- AnnotationDbi::select(gencode.txdb, keys = keys, columns="GENEID", keytype="TXNAME")
peaks.gc.gr$gene_name <- mapped.ids$GENEID
```

```{r}
# Add fasta_id from tx annotation used for Tosca as a new column

human.gr <- import.gff2(human.gtf)
human.gr <- keepStandardChromosomes(human.gr, pruning.mode = "coarse")
human.gr <- dropSeqlevels(human.gr, c("chrM", "chrY"), pruning.mode = "coarse")
human.df <- as.data.frame(human.gr)

genes.ls <- unique(peaks.gc.gr$gene_name) # create list of unique gene names from peak file to filter the human annotation

human.df <- human.df %>%
  filter(str_detect(fasta_id, paste(genes.ls, collapse = "|"))) # filter for gene names in the peak gr

human.df$row <- row.names(human.df)
human.df <- dplyr::rename(human.df, fasta_id_start = start, fasta_id_end = end)
human.df <- as.data.frame(human.df[,c("row", "fasta_id", "fasta_id_start", "fasta_id_end")])

peaks.gc.df <- as.data.frame(peaks.gc.gr)

peaks.gc.df <- merge_by_partial_string(human.df, peaks.gc.df)
peaks.gc.df <- peaks.gc.df %>%
  dplyr::select(-row)

# Add transcriptomic coordinates to the peaks file
peaks.df <- peaks.gc.df %>%
  mutate(tx_start = case_when((strand == "+") ~ start - fasta_id_start + 1,
                                     (strand == "-") ~  fasta_id_end - end + 1),
         tx_end = case_when((strand == "+") ~ end - fasta_id_start + 1,
                                   (strand == "-") ~  fasta_id_end - start + 1))

```

```{r}
peaks.df <- dplyr::rename(peaks.df, tx_name = name)

# Extract the start and end position of the stem-loop individually for each arm
arms.df <- cluster.duplexes.dt %>% 
  dplyr::select(name, seqnames, strand, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end)

# Merge df containing the peaks starts + 100 in genomic and transcriptomic coordinates to arms dataframe
arms.df <- as.data.frame(left_join(arms.df, peaks.df, by = c("name" = "id", "seqnames", "strand")))

```


#### From the annotated peaks coordinates calculate  tx coordinates of the  predicted stem

```{r}
# ==========
# Obtain coordinates for each arm of the stem loop
# ==========

# Calculate L and R arms transcriptomic coordinates
arms.df <- arms.df %>%
  mutate(L_tx_start = case_when((strand == "+") ~ L_genomic_start - fasta_id_start + 1,
                                     (strand == "-") ~  fasta_id_end - L_genomic_end + 1),
         L_tx_end = case_when((strand == "+") ~ L_genomic_end - fasta_id_start + 1,
                                   (strand == "-") ~  fasta_id_end - L_genomic_start + 1),
         R_tx_start = case_when((strand == "+") ~ R_genomic_start - fasta_id_start + 1,
                                     (strand == "-") ~ fasta_id_end - R_genomic_end + 1),
         R_tx_end = case_when((strand == "+") ~ R_genomic_end - fasta_id_start + 1,
                                   (strand == "-") ~ fasta_id_end - R_genomic_start + 1))
```


```{r}
# The peaks with gene IDs not present in fasta_ids of human annotation will have NAs instead of coordinates, so filtering them out
arms.df <- dplyr::filter(arms.df, !is.na(fasta_id))

# Check L and R arm coordinate widths are correct
stopifnot((arms.df$L_genomic_end - arms.df$L_genomic_start) == abs(arms.df$L_tx_end - arms.df$L_tx_start))
stopifnot((arms.df$R_genomic_end - arms.df$R_genomic_start) == abs(arms.df$R_tx_end - arms.df$R_tx_start))
```


```{r}
# Genomic (similar to tosca clusters table):
short_range.reformated.gc.df <- data.frame(name = arms.df$name, count = arms.df$score, L_seqnames=arms.df$fasta_id,	
                                     L_start=arms.df$L_tx_start, L_end=arms.df$L_tx_end, L_strand="+", L_genomic_seqnames=arms.df$seqnames,
                                     L_genomic_start=arms.df$L_genomic_start, L_genomic_end= arms.df$L_genomic_end,
                                     L_genomic_strand=arms.df$strand, R_seqnames=arms.df$fasta_id, R_start=arms.df$R_tx_start, R_end=arms.df$R_tx_end,
                                     R_strand="+", R_genomic_seqnames=arms.df$seqnames,
                                     R_genomic_start=arms.df$R_genomic_start,  R_genomic_end= arms.df$R_genomic_end,
                                     R_genomic_strand =arms.df$strand)

stopifnot(abs(short_range.reformated.gc.df$L_genomic_end - short_range.reformated.gc.df$L_genomic_start) ==
            abs(short_range.reformated.gc.df$L_end - short_range.reformated.gc.df$L_start))
stopifnot(abs(short_range.reformated.gc.df$R_genomic_end - short_range.reformated.gc.df$R_genomic_start) ==
            abs(short_range.reformated.gc.df$R_end - short_range.reformated.gc.df$R_start))
```


```{r}
# Export bed file
short_range.reformated.gc.dt <- data.table(short_range.reformated.gc.df)
# export_genomic_bed(short_range.reformated.gc.dt, paste0(data.dir, "/predicted_duplexes.bed"))
```

***
> Calculate overlap with STAU1 duplexes from hybrid reads

#### Cluster the linker and no linker hybrids


```{r}
# keep common columns
setdiff(colnames(nolinker.dt), colnames(linker.dt))
nolinker.dt[, c(setdiff(colnames(nolinker.dt), colnames(linker.dt))):=NULL]

all.hybrids.dt <- rbind(linker.dt, nolinker.dt)
nrow(all.hybrids.dt)

all.hybrids.dt[, c("cluster", "cluster_hybrid_count"):=NULL]

# ==========
# Remove rRNA and tRNA hybrids
# ==========

all.hybrids.dt[, total_count := NULL]
all.hybrids.dt <- all.hybrids.dt[, total_count := .N, by = .(L_seqnames, R_seqnames)]
all.hybrids.dt <- all.hybrids.dt[L_seqnames == R_seqnames]
all.hybrids.dt <- all.hybrids.dt[!(L_seqnames == "rRNA_45S" & R_seqnames == "rRNA_45S")]
all.hybrids.dt <- all.hybrids.dt[!(L_seqnames == "rDNA" & R_seqnames == "rDNA")]
all.hybrids.dt <- all.hybrids.dt[!(L_seqnames == "rRNA_5S" & R_seqnames == "rRNA_5S")]
all.hybrids.dt <- all.hybrids.dt[!(L_seqnames == "rRNA5S" & R_seqnames == "rRNA5S")]
all.hybrids.dt <- all.hybrids.dt[!grepl("tRNA", L_seqnames)]
all.hybrids.dt <- all.hybrids.dt[!grepl("tRNA", R_seqnames)]

nrow(all.hybrids.dt)
```


```{r}
# ==========
# Cluster
# ==========

all.list <- split(all.hybrids.dt, by = c("L_seqnames", "R_seqnames"))
all.clusters.list <- parallel::mclapply(all.list, cluster_hybrids, percent_overlap = 0.5, mc.cores = 4)
all.clusters.dt <- rbindlist(all.clusters.list, use.names = TRUE, fill = TRUE)

#all.clusters.dt[L_seqnames == R_seqnames][!L_seqnames %in% c("tRNA", "rDNA", "rRNA_5S")][grep("C", cluster), .N, by = .(cluster, L_seqnames, R_seqnames)]
all.collapsed  <- collapse_clusters(all.clusters.dt, mode = "wide")

# Get genomic coordinates
all.collapsed <- convert_coordinates(all.collapsed, genes.gr)

# Export bed file
all.collapsed.dt <- data.table(all.collapsed)
# export_genomic_bed(all.collapsed.dt, paste0(data.dir, "/collapsed_hybrid_duplexes.bed"))
```

```{r}
# Export reformated file, it will be used for clustering all datasets

fwrite(short_range.reformated.gc.df, paste0(data.dir, "/short_range_duplexes.tsv.gz"), sep = "\t")

```

#### Find overlaps with merged clusters (no linker and linker)

```{r}
ol <- primavera::find_valid_hybrid_overlaps(as.data.table(short_range.reformated.gc.df), all.collapsed)
nonhyb_overlapped.dt <- short_range.reformated.gc.df[unique(ol$queryHits),]
```

```{r}
nonhyb_count <- nrow(cluster.duplexes.dt)
hyb_clusters_count <- nrow(all.collapsed)
nonhyb_ol_count <- nrow(nonhyb_overlapped.dt)

olap_counts <- c(Predicted_short_range_duplexes = nonhyb_count-nonhyb_ol_count, hiCLIP_duplexes = hyb_clusters_count-nonhyb_ol_count, "Predicted_short_range_duplexes&hiCLIP_duplexes" = nonhyb_ol_count)

pdf(file=paste0(plots.dir,"/short_range_overlap.pdf"), onefile=FALSE, width = 7, height = 5) 

upset(fromExpression(olap_counts),
      order.by = "freq",
      decreasing = T,
      number.angles = 0,
      text.scale = 1.1,
      point.size = 2.8,
      line.size = 1,
      mainbar.y.label = "Intersecting number of duplexes",
      sets.x.label = "Total number of duplexes",
      empty.intersections = "off"
      )

dev.off()
```


## Fig 3 G

### Examples of short-range structures

***
> Short-range structure that overlaps with hybrid duplexes

```{r}
semi_join(cluster.duplexes.dt, nonhyb_overlapped.dt, by = "name")

```
```{r}
ex1.df <- dplyr::filter(cluster.duplexes.dt, name == "ID10081")
```

***
> Short-range structure that doesn't overlap with hybrid duplexes

```{r}
anti_join(cluster.duplexes.dt, nonhyb_overlapped.dt, by = "name")
```

```{r}
ex2.df <- dplyr::filter(cluster.duplexes.dt, name == "ID10083")
```

```{r}
short_range_exaples.dt <- as.data.table(rbind(ex1.df, ex2.df))
short_range_exaples.dt$q <- 0
short_range_exaples_bp.dt <- short_range_exaples.dt[, .(seqnames, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, q)]
# fwrite(short_range_exaples_bp.dt, sep = "\t", col.names = FALSE, file = "short_range_examples.bp")

```

```{r}
clusters_examples.dt <- all.collapsed %>%
  dplyr::filter(name == "C001-PIN1:ENSG00000127445.13-PIN1:ENSG00000127445.13" |
                  name == "C002-PIN1:ENSG00000127445.13-PIN1:ENSG00000127445.13")
clusters_examples.dt

```

```{r}
clusters_examples.dt$q <- 0
clusters_examples_bp.dt <- clusters_examples.dt[, .(L_genomic_seqnames, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, q)]
#fwrite(clusters_examples_bp.dt, sep = "\t", col.names = FALSE, file = "long_range_examples.bp")
```



```{r}
fa.dt <- data.table(gene_id = names(fa.dss), sequence = as.character(fa.dss))
short_range.reformated.gc.df <- get_sequence(as.data.table(short_range.reformated.gc.df), fa.dt)
stopifnot(!any(is.na(c(short_range.reformated.gc.df$L_sequence, short_range.reformated.gc.df$L_sequence))))
cluster.duplexes.dt <- left_join(cluster.duplexes.dt, dplyr::select(short_range.reformated.gc.df, name, L_sequence, R_sequence))
```

```{r}
x <- get_stem_loop_sequence(as.data.table(short_range.reformated.gc.df), fa.dt)
cluster.duplexes.dt <- left_join(cluster.duplexes.dt, dplyr::select(x, name, stem_loop_sequence))
```

```{r}
dplyr::filter(cluster.duplexes.dt, name == "ID10083" | name == "ID10081")
```


# Supplementary figure / Other RBPs

## Fig 3 D

### Duplex length

```{r}
cluster.duplexes.dt <- cluster.duplexes.dt %>%
  rowwise() %>%
  mutate(total_paired = str_count(L_db, "\\(")) %>%
  ungroup()
```


```{r}
m_motif_structures <- list(nrow(cluster.duplexes.dt))
names(m_motif_structures) <- "M motif duplexes (clusters 1, 2, 3)"
m_motif_min10bp <- list(nrow(cluster.duplexes.dt[cluster.duplexes.dt$total_paired >= 10,]))
names(m_motif_min10bp) <-"M motif duplexes >= 10 bp"

m_motif_max9bp <- list(nrow(cluster.duplexes.dt) - nrow(cluster.duplexes.dt[cluster.duplexes.dt$total_paired >= 10,]))
names(m_motif_max9bp) <- "M motif duplexes < 10 bp"

no_m_motif <- list(nrow(stau1.prob.df) - nrow(cluster.duplexes.dt))
names(no_m_motif) <- "No M motif"
structure_types.ls <- c(no_m_motif, m_motif_max9bp, m_motif_min10bp)
types.df <- data.frame(structure_types = names(structure_types.ls), count = unlist(structure_types.ls, use.names=FALSE))

data_counts.df <- types.df %>%
  mutate(percentage = scales::percent(count / sum(count))) %>%
  mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
  mutate(pos = cumsum(percentage) - percentage/2)

types_colours <- c("No M motif" = "#216b77", "M motif duplexes >= 10 bp" = "#31a1b3", "M motif duplexes < 10 bp" = "#5ec3d3")

# data_counts.df$structure_types <- factor(data_counts.df$structure_types, levels = "No M motif", "M motif duplexes < 10 bp", "M motif duplexes >= 10 bp")
  
  pie.gg <- ggplot(data_counts.df, aes(x="", y=count, fill=reorder(structure_types, count))) +
    geom_bar(stat = "identity", width = 0.05, color="black", alpha = 0.5) +
    coord_polar("y", start=0) +
    #scale_fill_brewer(palette = "Blues", direction = -1) +
    scale_fill_manual(values = types_colours) +
    ggrepel::geom_label_repel(aes(label = paste0(percentage,"%")), size = 3.5, show.legend = FALSE, position = position_stack(vjust = .5)) +
    ggrepel::geom_label_repel(aes(label = count), size = 2.5, show.legend = FALSE, position = position_stack(vjust = .3)) +
    guides(fill = guide_legend(title = "Structure type")) +
    theme_void() # remove background, grid, numeric labels

pie.gg

# ggsave(paste0(plots.dir,"/",prefix,"_structure_types.pdf"), pie.gg, width = 5, height = 4, dpi = 300)
```


```{r}
total_paired_median <- cluster.duplexes.dt %>%
  dplyr::summarize(Median = median(total_paired, na.rm = TRUE))
total_paired_median

# Plot
s.gg <- ggplot(cluster.duplexes.dt, aes(x=total_paired)) + 
  #geom_histogram(bins = 45, color="black", fill = "#DEEBF7") +
  geom_density(color = "#31a1b3") +
  theme_minimal_grid() +
  geom_vline(data=total_paired_median, aes(xintercept=Median), color = "grey",
             linetype="dashed") +
  #scale_x_log10() + annotation_logticks(sides = "b") + #breaks=c(3,5,7, 10,30))
  # ggtitle("Distribution of hairpin loop sizes") +
  xlab("Paired residues") +
  ylab("Density")

s.gg
```


## TDP43

```{r}
prob.file <- prob.files[str_detect(prob.files, "tardp")]
shuff.file <- shuff.files[str_detect(prob.files, "tardp")]
prob.name <- str_split(prob.file, pattern = "\\/")[[1]]
prob.name <- prob.name[length(prob.name)]
prob.name <- str_to_upper(str_split(prob.name, pattern = "_")[[1]][1]) #RBP name

prefix <- basename(prob.file)
prefix <- str_split(prefix, ".tsv")[[1]][1]
```

```{r}
# Load metaprofile dataframes (df output from get_structure_metaprofile.R)

tardp.prob.df <- data.table::fread(prob.file, skip = 1, data.table = FALSE)
tardp.prob.df <- column_to_rownames(tardp.prob.df, var = "V1")
tardp.prob.df <- drop_na(tardp.prob.df)
colnames(tardp.prob.df) <- seq(1-(ncol(tardp.prob.df)+1)/2, (ncol(tardp.prob.df)-1)/2) # center colnames on zero

```


```{r}
tardp.prob.mean.df <- get_metaprofile_mean(prob.file)
tardp.prob.mean.df$Sample <- prob.name

if (shuffled == TRUE) {
 
  tardp.shuff.mean.df <- get_metaprofile_mean(shuff.file)
  tardp.shuff.mean.df$Sample <- "Control (shuffled)"
  tardp.data.df <- rbind(tardp.prob.mean.df, tardp.shuff.mean.df)
   tardp.data.df$peaks_count <- nrow(tardp.prob.df)
} else {
   tardp.data.df <- tardp.prob.mean.df
   tardp.data.df$peaks_count <- nrow(tardp.prob.df)
}

# plot the mean probability and standard error of the mean
tardp.profile.gg <- plot_metaprofile(tardp.data.df)
tardp.profile.gg <- append_layers(tardp.profile.gg, annotate("rect", xmin = 15, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#DEEBF7"), position = "bottom")
tardp.profile.gg
```

## HUR

```{r}
prob.file <- prob.files[str_detect(prob.files, "hur")]
shuff.file <- shuff.files[str_detect(prob.files, "hur")]
prob.name <- str_split(prob.file, pattern = "\\/")[[1]]
prob.name <- prob.name[length(prob.name)]
prob.name <- str_to_upper(str_split(prob.name, pattern = "_")[[1]][1]) #RBP name

prefix <- basename(prob.file)
prefix <- str_split(prefix, ".tsv")[[1]][1]
```

```{r}
# Load metaprofile dataframes (df output from get_structure_metaprofile.R)

hur.prob.df <- data.table::fread(prob.file, skip = 1, data.table = FALSE)
hur.prob.df <- column_to_rownames(hur.prob.df, var = "V1")
hur.prob.df <- drop_na(hur.prob.df)
colnames(hur.prob.df) <- seq(1-(ncol(hur.prob.df)+1)/2, (ncol(hur.prob.df)-1)/2) # center colnames on zero

```


```{r}
hur.prob.mean.df <- get_metaprofile_mean(prob.file)
hur.prob.mean.df$Sample <- prob.name

if (shuffled == TRUE) {
 
  hur.shuff.mean.df <- get_metaprofile_mean(shuff.file)
  hur.shuff.mean.df$Sample <- "Control (shuffled)"
  hur.data.df <- rbind(hur.prob.mean.df, hur.shuff.mean.df)
  hur.data.df$peaks_count <- nrow(hur.prob.df)
} else {
  hur.data.df <- hur.prob.mean.df
  hur.data.df$peaks_count <- nrow(hur.prob.df)
}

# plot the mean probability and standard error of the mean
hur.profile.gg <- plot_metaprofile(hur.data.df)
hur.profile.gg <- append_layers(hur.profile.gg, annotate("rect", xmin = 15, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#DEEBF7"), position = "bottom")
hur.profile.gg

```


# Combine all RBPs (Figure 3 B)

```{r}
hur.data.df$Experiment <- as.factor("HuR")
tardp.data.df$Experiment <- as.factor("TDP43")
stau1.data.df$Experiment <- as.factor("STAU1")

merged.data.df <- rbind(stau1.data.df, hur.data.df, tardp.data.df)
```


```{r}
merged.gg <- ggplot(merged.data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
    geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob)), color = "grey80", fill = "grey80") +
    geom_line(aes(linetype = Sample)) +
    scale_linetype_manual(values=c("longdash", "solid","solid", "solid" ))+
    scale_color_manual(values=c('#E69F00', '#222222', '#222222', '#222222'))+
    geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
    ylim(c(0.40, 0.60))+
    xlab("Distance relative to the peak start (nt)")+
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Mean probability") +
    labs(linetype = "Sample") +
    geom_text(aes(x = 55, y = 0.59,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 4) +
  facet_grid(rows = vars(Experiment))

merged.gg <-
  append_layers(merged.gg, annotate("rect", xmin = 15, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#DEEBF7"), position = "bottom")
merged.gg <- merged.gg + theme(strip.background = element_blank())
merged.gg
```

```{r}
#ggsave(paste0(data.dir,"/RBPs_metaprofile_paired.pdf"), merged.gg, width = 3, height = 5)
```

## All in one plot

```{r}
data.df <- merged.data.df %>%
  dplyr::filter(!((Sample == "Control (shuffled)" & Experiment == "HuR") | (Sample == "Control (shuffled)" & Experiment == "TDP43")))
```

```{r}
stau1.counts <- unique(stau1.data.df$peaks_count)
hur.counts <- unique(hur.data.df$peaks_count)
tardp.counts <- unique(tardp.data.df$peaks_count)
```

```{r}
merged.gg <- ggplot(data.df, aes(x=as.numeric(pos), y=mean_prob, group = Sample, color = Sample)) +
  scale_fill_manual(values=c('#222222','#E69F00', '#CD5C5C', '#A569BD')) +
  scale_color_manual(values=c('#222222','#E69F00', '#CD5C5C', '#A569BD')) +
  geom_ribbon(aes(ymin=(mean_prob-std_prob), ymax=(mean_prob+std_prob), fill = Sample), alpha = 0.3, color = NA) +
  geom_line(aes(linetype = Sample)) +
  scale_linetype_manual(values=c("longdash", "solid","solid", "solid" )) +
  geom_vline(xintercept = 0, linetype = "dashed", color ="grey60", size = 0.5) +
  ylim(c(0.40, 0.60)) +
  xlab("Distance relative to the peak start (nt)") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  theme_minimal_grid() +
    ylab("Mean probability") +
    labs(linetype = "Sample") +
    # geom_text(aes(x = 55, y = 0.60,label = paste0("n = ", peaks_count)), inherit.aes = FALSE, size = 3) 
  geom_text(aes(x = -80, y = 0.43,label = paste0("n = ", hur.counts)), inherit.aes = FALSE, size = 4, color = "#E69F00") +
  geom_text(aes(x = -80, y = 0.415,label = paste0("n = ", hur.counts)), inherit.aes = FALSE, size = 4, color = "#CD5C5C") +
  geom_text(aes(x = -80, y = 0.40,label = paste0("n = ", tardp.counts)), inherit.aes = FALSE, size = 4, color = "#A569BD") 
  #facet_grid(~Experiment)

merged.gg <-
  append_layers(merged.gg, annotate("rect", xmin = 15, xmax = 75, ymin = -Inf, ymax = Inf, 
           alpha = 0.5, fill = "#DEEBF7"), position = "bottom")
merged.gg <- merged.gg + theme(strip.background = element_blank())
merged.gg

# ggsave(paste0(data.dir,"/RBPs_metaprofile_paired_v2.pdf"), merged.gg, width = 4, height = 4)
```


```{r}
# p = c(0, 0.25, 0.50, 0.75, 1)
#   
#   coord.dt <- cluster.duplexes.dt
#   coord.dt$q <- cut(cluster.duplexes.dt$score, 
#                     breaks = quantile(coord.dt$score, probs = p), 
#                     include.lowest = TRUE, 
#                     labels = 0:(length(p) - 2))
#   
#   cols <- tableau_seq_gradient_pal('Blue')(seq(0, 1, length = length(p) - 1))
#   cols.dt <- rbindlist(lapply(cols, function(x) data.table(paste(as.vector(col2rgb(x)), collapse = "\t"))))
#   cols.dt[, `:=` (colour = "color:",
#                   annotation = paste("Count quantile", 1:(length(p) - 1)))]
#   setcolorder(cols.dt, c("colour", "V1", "annotation"))
# 
# coord.dt <- as.data.table(coord.dt)
# bp.dt <- coord.dt[, .(seqnames, L_genomic_start, L_genomic_end, R_genomic_start, R_genomic_end, q)]
#   setorder(bp.dt, q)
#   
#   fwrite(cols.dt, sep = "\t", col.names = FALSE, quote = FALSE, file = "short_range.bp")
#   fwrite(bp.dt, sep = "\t", col.names = FALSE, file = "short_range.bp", append = TRUE)

```